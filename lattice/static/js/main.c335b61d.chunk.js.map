{"version":3,"sources":["game/geometry-cache.ts","game/scene-node.ts","game/voxel.ts","game/health.ts","game/utils.ts","game/tracer.ts","game/team.ts","game/lattice.ts","game/game.ts","Display.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["SPHERE_GEOMETRIES","Map","getCachedSphereGeometry","radius","has","get","geometry","SphereGeometry","set","BOX_GEOMETRIES","getCachedBoxGeometry","size","BoxGeometry","GRADIENT_MAPS","getCachedGradientMap","tones","texels","Uint8Array","i","length","texture","DataTexture","LuminanceFormat","minFilter","NearestFilter","magFilter","generateMipmaps","SceneNode","group","Group","this","position","scale","Voxel","color","gradientTones","highlightColor","highlightScalar","dotRadius","shellGeometry","shellMaterial","shellMesh","highlightGeometry","highlightMaterial","highlightMesh","dotGeometry","dotMaterial","dotMesh","health","MeshToonMaterial","gradientMap","side","BackSide","Mesh","renderOrder","add","multiplyScalar","Color","visible","amount","equals","overflow","copy","Math","floor","healthToScalar","MAXIMUM_HEALTH","darkenColor","delta","getHSL","h","s","l","setHSL","randomInt","min","max","random","Tracer","team","start","path","outlineGeometry","outlineMaterial","outlineMesh","alpha","stepTime","stepSource","Vector3","easing","sigmoid","FrontSide","MeshPhongMaterial","complete","step","peek","dest","addVectors","time","lerpVectors","poll","Path","steps","index","PathStep","direction","distance","vector","Direction","UP","DOWN","LEFT","RIGHT","FORWARD","BACK","k","base","t","exp","correction","MathUtils","clamp","Team","id","ALL","TEAM_A","TEAM_B","TEAM_C","TEAM_D","Lattice","voxelSize","spacing","volume","voxels","guidelines","tracers","Array","tracerSpawnThreshold","tracerSpawnCounter","shellsMesh","x","y","z","MeshBasicMaterial","InstancedMesh","setMatrixAt","Matrix4","makeTranslation","Guidelines","tracer","push","fromID","count","curr","v","addTracer","completeTracers","update","hasReachedVoxel","getVoxelFromWorldCoordinates","damage","dead","remove","splice","getVoxel","material","segments","LineBasicMaterial","halfLength","points","a","b","c","gapStart","gapEnd","len","LineSegments","BufferGeometry","setFromPoints","computeLineDistances","Game","canvas","renderer","effects","camera","controls","scene","ambient","sun","lattice","WebGLRenderer","antialias","setSize","clientWidth","clientHeight","PerspectiveCamera","OrbitControls","maxPolarAngle","PI","dampingFactor","enableDamping","Scene","background","AmbientLight","PointLight","EffectComposer","addPass","RenderPass","aspect","updateProjectionMatrix","render","Display","props","ref","React","createRef","game","current","previousTime","performance","now","requestAnimationFrame","draw","currentTime","className","Component","App","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.c335b61d.chunk.js","sourcesContent":["import {\n    BoxGeometry,\n    DataTexture,\n    EdgesGeometry,\n    Geometry,\n    LuminanceFormat,\n    NearestFilter,\n    SphereGeometry,\n    Texture\n} from \"three\";\n\nconst SPHERE_GEOMETRIES = new Map<number, Geometry>();\n\nexport const getCachedSphereGeometry = (radius: number): Geometry => {\n    if (SPHERE_GEOMETRIES.has(radius)) {\n        return SPHERE_GEOMETRIES.get(radius)!;\n    }\n\n    const geometry = new SphereGeometry(radius);\n    SPHERE_GEOMETRIES.set(radius, geometry);\n    return geometry;\n}\n\nconst BOX_GEOMETRIES = new Map<number, Geometry>();\n\nexport const getCachedBoxGeometry = (size: number): Geometry => {\n    if (BOX_GEOMETRIES.has(size)) {\n        return BOX_GEOMETRIES.get(size)!;\n    }\n\n    const geometry = new BoxGeometry(size, size, size);\n    BOX_GEOMETRIES.set(size, geometry);\n    return geometry;\n}\n\nconst EDGE_GEOMETRIES = new Map<number, EdgesGeometry>();\n\nexport const getCachedEdgesGeometry = (size: number): EdgesGeometry => {\n    if (EDGE_GEOMETRIES.has(size)) {\n        return EDGE_GEOMETRIES.get(size)!;\n    }\n\n    const geometry = new EdgesGeometry(getCachedBoxGeometry(size));\n    EDGE_GEOMETRIES.set(size, geometry);\n    return geometry;\n}\n\nconst GRADIENT_MAPS = new Map<number, Texture>();\n\nexport const getCachedGradientMap = (tones: number): Texture => {\n    if (GRADIENT_MAPS.has(tones)) {\n        return GRADIENT_MAPS.get(tones)!;\n    }\n\n    const texels = new Uint8Array( tones);\n    for (let i = 0; i <= texels.length; i ++ ) {\n        texels[i] = (i / texels.length) * 0x100;\n    }\n\n    const texture = new DataTexture(texels, texels.length, 1, LuminanceFormat);\n    texture.minFilter = NearestFilter;\n    texture.magFilter = NearestFilter;\n    texture.generateMipmaps = false;\n    GRADIENT_MAPS.set(tones, texture);\n\n    return texture;\n}\n\nexport const createGradientMap = (tones: number): Texture => {\n    const texels = new Uint8Array( tones);\n    for (let i = 0; i <= texels.length; i ++ ) {\n        texels[i] = (i / texels.length) * 0x100;\n    }\n\n    const texture = new DataTexture(texels, texels.length, 1, LuminanceFormat);\n    texture.minFilter = NearestFilter;\n    texture.magFilter = NearestFilter;\n    texture.generateMipmaps = false;\n    GRADIENT_MAPS.set(tones, texture);\n\n    return texture;\n}","import {Group, Vector3} from \"three\";\n\nexport default abstract class SceneNode {\n    readonly group: Group = new Group();\n\n    get position(): Vector3 {\n        return this.group.position;\n    }\n\n    get scale(): Vector3 {\n        return this.group.scale;\n    }\n}","import {\n    BackSide,\n    BoxGeometry,\n    Color, DataTexture,\n    EdgesGeometry, Geometry, Group,\n    LineBasicMaterial,\n    LineSegments,\n    LuminanceFormat, Material,\n    Mesh, MeshPhongMaterial,\n    MeshToonMaterial,\n    NearestFilter, OctahedronGeometry,\n    Texture\n} from 'three';\n\nimport {\n    getCachedSphereGeometry,\n    getCachedGradientMap,\n    getCachedBoxGeometry\n} from \"./geometry-cache\";\n\nimport SceneNode from \"./scene-node\";\n\n/**\n * A voxel is a\n */\nexport class Voxel extends SceneNode {\n    readonly shellGeometry: Geometry;\n    readonly shellMaterial: MeshToonMaterial;\n    readonly shellMesh: Mesh;\n\n    readonly highlightGeometry: Geometry;\n    readonly highlightMaterial: MeshToonMaterial;\n    readonly highlightMesh: Mesh;\n\n    readonly dotGeometry: Geometry;\n    readonly dotMaterial: MeshToonMaterial;\n    readonly dotMesh: Mesh;\n\n    health: number = 0;\n\n    constructor(\n        size: number,\n        color: Color,\n        gradientTones: number,\n        highlightColor: Color,\n        highlightScalar: number,\n        dotRadius: number,\n    ) {\n        super();\n\n        this.shellGeometry = getCachedBoxGeometry(size);\n        this.shellMaterial = new MeshToonMaterial({\n            color: color,\n            gradientMap: getCachedGradientMap(gradientTones),\n            side: BackSide\n        });\n        this.shellMesh = new Mesh(this.shellGeometry, this.shellMaterial);\n        this.shellMesh.renderOrder = 1;\n        this.group.add(this.shellMesh);\n\n        this.highlightGeometry = getCachedBoxGeometry(size);\n        this.highlightMaterial = new MeshToonMaterial({\n            color: highlightColor,\n            gradientMap: getCachedGradientMap(gradientTones),\n            side: BackSide\n        });\n        this.highlightMesh = new Mesh(this.highlightGeometry, this.highlightMaterial);\n        this.highlightMesh.scale.multiplyScalar(highlightScalar);\n        this.highlightMesh.renderOrder = 0;\n        this.group.add(this.highlightMesh);\n\n        this.dotGeometry = getCachedSphereGeometry(dotRadius);\n        this.dotMaterial = new MeshToonMaterial({\n            color: new Color('#ff0000'),\n            gradientMap: getCachedGradientMap(gradientTones),\n        });\n        this.dotMesh = new Mesh(this.dotGeometry, this.dotMaterial);\n        this.dotMesh.scale.multiplyScalar(1.1);\n        this.dotMesh.visible = false;\n        this.dotMesh.renderOrder = 2;\n        this.group.add(this.dotMesh);\n    }\n\n    damage(amount: number, color: Color): number {\n        if (this.dotMaterial.color.equals(color)) {\n            return 0;\n        }\n\n        let overflow: number = 0;\n\n        if (this.health === 0) {\n            if (amount === 1) {\n                this.dotMaterial.color = new Color().copy(color);\n                this.dotMesh.visible = true;\n                this.health = 1;\n                overflow = 1;\n            } else {\n                this.dotMaterial.color = new Color().copy(color);\n                this.dotMesh.visible = true;\n                this.health = Math.floor(amount / 2);\n                overflow = amount - this.health;\n            }\n        } else if (this.health - amount < 0) {\n            this.dotMaterial.color = new Color().copy(color);\n            this.dotMesh.visible = true;\n            this.health = Math.floor((amount - this.health) / 2);\n            overflow = amount - this.health;\n        } else if(this.health - amount === 0) {\n            this.dotMaterial.color = new Color().copy(this.shellMaterial.color);\n            this.dotMesh.visible = false;\n            this.health = 0;\n            overflow = this.health;\n        } else {\n            this.health -= amount;\n            overflow = amount;\n        }\n\n        const scale = Math.floor((this.health + 100) / 100) / 6;\n        this.dotMesh.scale.set(1, 1, 1).multiplyScalar(scale).multiplyScalar(1.1);\n\n        return overflow;\n    }\n}","export const MAXIMUM_HEALTH = 500;\n\nconst SCALAR_GRANULARITY = 5;\n\nexport const healthToScalar = (health: number): number => {\n    const k = MAXIMUM_HEALTH / SCALAR_GRANULARITY;\n    return Math.floor(((health + k) / k)) / (SCALAR_GRANULARITY + 1);\n}","import {Color} from \"three\";\n\nexport const darkenColor = (color: Color, delta: number): Color => {\n    let {h, s, l} = color.getHSL({h: 0, s: 0, l: 0});\n    l -= delta;\n    if (l < 0) {\n        l = 0;\n    }\n    return new Color().setHSL(h, s, l);\n}\n\nexport const randomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min)) + min;\n}","import {\n    BackSide,\n    Color, DataTexture, FrontSide, Geometry,\n    Group, LuminanceFormat, Material, MathUtils,\n    Mesh,\n    MeshBasicMaterial,\n    MeshPhongMaterial, MeshToonMaterial, NearestFilter, OctahedronGeometry,\n    PointLight,\n    SphereGeometry,\n    Vector3\n} from \"three\";\nimport {getCachedGradientMap, getCachedSphereGeometry} from \"./geometry-cache\";\nimport SceneNode from \"./scene-node\";\nimport {healthToScalar} from \"./health\";\nimport {Dir} from \"fs\";\nimport {Team} from \"./team\";\nimport {darkenColor} from \"./utils\";\n\nconst RADIUS: number = 6;\n\nexport default class Tracer extends SceneNode {\n\n    readonly shellGeometry: Geometry;\n    readonly shellMaterial: MeshToonMaterial;\n    readonly shellMesh: Mesh;\n\n    readonly outlineGeometry: Geometry;\n    readonly outlineMaterial: MeshPhongMaterial;\n    readonly outlineMesh: Mesh;\n\n    private alpha: number = 0;\n    private stepTime: number = 0;\n    private stepSource: Vector3 = new Vector3();\n    private easing: (t: number) => number = sigmoid(5.5);\n\n    /**\n     *\n     * @param team\n     * @param start\n     * @param path\n     * @param health\n     */\n    constructor(\n        readonly team: Team,\n        public health: number,\n        readonly start: Vector3,\n        readonly path: Path,\n    ) {\n        super();\n\n        this.shellGeometry = getCachedSphereGeometry(RADIUS);\n        this.shellMaterial = new MeshToonMaterial({\n            color: team.color,\n            gradientMap: getCachedGradientMap(10),\n            side: FrontSide\n        });\n        this.shellMesh = new Mesh(this.shellGeometry, this.shellMaterial);\n        this.shellMesh.renderOrder = 1;\n        this.group.add(this.shellMesh);\n\n        this.outlineGeometry = getCachedSphereGeometry(RADIUS);\n        this.outlineMaterial = new MeshPhongMaterial({\n            color: darkenColor(this.team.color, 0.2),\n            side: BackSide\n        });\n        this.outlineMesh = new Mesh(this.outlineGeometry, this.outlineMaterial);\n        this.outlineMesh.scale.multiplyScalar(1.05);\n        this.outlineMesh.renderOrder = 0;\n        this.group.add(this.outlineMesh);\n\n        this.position.copy(this.stepSource);\n        this.scale.multiplyScalar(healthToScalar(this.health));\n\n        this.stepSource.copy(this.start);\n    }\n\n    /**\n     * Damages the tracer, updating its scale as needed.\n     *\n     * @param amount the amount of damage to apply to the tracer.\n     */\n    damage(amount: number) {\n        this.health -= amount;\n        if (this.health < 0) {\n            this.health = 0;\n        }\n\n        if (this.health !== 0) {\n            this.group.scale.set(1, 1, 1).multiplyScalar(healthToScalar(this.health));\n        }\n    }\n\n    update(delta: number) {\n        if (this.path.complete()) {\n            return;\n        }\n\n        const step = this.path.peek();\n        const dest = new Vector3().addVectors(\n            this.stepSource,\n            step.delta(),\n        );\n\n        this.stepTime += delta;\n\n        this.alpha = this.easing(this.stepTime / step.time);\n        if (this.alpha > 1) {\n            this.alpha = 1;\n        }\n\n        this.position.copy(new Vector3().lerpVectors(this.stepSource, dest, this.alpha));\n\n        if (this.alpha === 1.0) {\n            this.path.poll();\n\n            this.stepSource = dest;\n            this.alpha = this.stepTime = 0;\n        }\n    }\n\n    hasReachedVoxel(): boolean {\n        return this.alpha === 0;\n    }\n\n    /**\n     * Gets if the tracer is dead either because it has zero health or it reached the end of its path.\n     */\n    dead() : boolean {\n        return this.health === 0 || this.path.complete();\n    }\n}\n\nexport class Path {\n    private index = 0;\n\n    constructor(readonly steps: PathStep[]) {}\n\n    peek(): PathStep {\n        return this.steps[this.index];\n    }\n\n    poll(): PathStep {\n        return this.steps[this.index++];\n    }\n\n    complete(): boolean {\n        return this.index === this.steps.length;\n    }\n}\n\nexport class PathStep {\n\n    /**\n     *\n     * @param direction\n     * @param distance\n     * @param time the time in milliseconds that the step should be taken.\n     */\n    constructor(readonly direction: Direction, readonly distance: number, readonly time: number) {\n    }\n\n    delta(): Vector3 {\n        return new Vector3().copy(this.direction.vector).multiplyScalar(this.distance);\n    }\n}\n\nexport class Direction {\n    public static UP = new Direction(new Vector3(0, 1, 0));\n    public static DOWN = new Direction(new Vector3(0, -1, 0));\n    public static LEFT = new Direction(new Vector3(1, 0, 0));\n    public static RIGHT = new Direction(new Vector3(-1, 0, 0));\n    public static FORWARD = new Direction(new Vector3(0, 0, 1));\n    public static BACK = new Direction(new Vector3(0, 0, -1));\n\n    private constructor(readonly vector: Vector3) {}\n}\n\n/**\n * Factory for sigmoid functions with a specific k value. For more information about sigmoid functions go here:\n * https://en.wikipedia.org/wiki/Sigmoid_function.\n *\n * @param k the sigmoid k value.\n */\nconst sigmoid = (k: number) => {\n    const base = (t: number) => {\n        return (1 / (1 + Math.exp(-k * t))) - 0.5;\n    }\n\n    const correction = 0.5 / base(1);\n\n    return (t: number): number => {\n        t = MathUtils.clamp(t, 0, 1);\n        return correction * base(2 * t - 1) + 0.5;\n    }\n}","import {Color} from \"three\";\n\nexport class Team {\n    private static ALL = new Map<number, Team>();\n\n    public static TEAM_A = new Team(0, new Color().setHSL(0.0, 0.5, 0.5));\n    public static TEAM_B = new Team(1, new Color().setHSL(0.4, 0.5, 0.5));\n    public static TEAM_C = new Team(2, new Color().setHSL(0.6, 0.5, 0.5));\n    public static TEAM_D = new Team(3, new Color().setHSL(0.8, 0.5, 0.5));\n\n    private constructor(readonly id: number, readonly color: Color) {\n        Team.ALL.set(id, this);\n    }\n\n    public static fromID(id: number): Team | undefined {\n        return Team.ALL.get(id);\n    }\n\n    public static count(): number {\n        return Team.ALL.size;\n    }\n}","import {Voxel} from './voxel';\nimport {\n    BackSide,\n    BoxGeometry,\n    BufferGeometry,\n    Color, Geometry,\n    InstancedBufferGeometry, InstancedMesh,\n    LineBasicMaterial,\n    LineDashedMaterial,\n    LineSegments,\n    Material, Matrix4, MeshBasicMaterial, MeshToonMaterial,\n    Vector3\n} from \"three\";\nimport {Point} from \"./point\";\nimport Tracer, {Direction, Path, PathStep} from \"./tracer\";\nimport SceneNode from \"./scene-node\";\nimport {MAXIMUM_HEALTH} from \"./health\";\nimport {randomInt} from \"./utils\";\nimport {Team} from \"./team\";\nimport {createGradientMap, getCachedBoxGeometry, getCachedGradientMap} from \"./geometry-cache\";\n\nexport class Lattice extends SceneNode {\n    readonly volume: number;\n    readonly length: number;\n    readonly voxels: Voxel[][][];\n    readonly guidelines: Guidelines;\n    readonly tracers: Tracer[] = new Array<Tracer>();\n\n    // TODO: Remove.\n    private tracerSpawnThreshold: number = 300;\n    private tracerSpawnCounter: number = 0;\n\n    private shellGeometry: BoxGeometry;\n    private shellMaterial: MeshBasicMaterial;\n    private shellsMesh: InstancedMesh;\n\n    private highlightGeometry: BoxGeometry;\n    private highlightMaterial: MeshBasicMaterial;\n    private highlightMesh: InstancedMesh;\n\n    constructor(\n        readonly size: number,\n        readonly voxelSize: number,\n        readonly spacing: number\n    ) {\n        super();\n\n        this.volume = this.size * this.size * this.size;\n\n        this.length = (this.size - 1) * this.spacing;\n\n        this.voxels = new Array<Array<Array<Voxel>>>(this.size);\n        for (let x = 0; x < this.size; x++) {\n            this.voxels[x] = new Array<Array<Voxel>>(this.size);\n            for (let y = 0; y < this.size; y++) {\n                this.voxels[x][y] = new Array<Voxel>(this.size);\n            }\n        }\n\n        for (let x = 0; x < this.size; x++) {\n            for (let y = 0; y < this.size; y++) {\n                for (let z = 0; z < this.size; z++) {\n                    const voxel = this.voxels[x][y][z] = new Voxel(\n                        voxelSize,\n                        new Color('#111111'),\n                        5,\n                        new Color('#ffffff'),\n                        1.05,\n                        6\n                    );\n\n                    voxel.group.position.set(\n                        x * this.spacing - this.length / 2,\n                        y * this.spacing - this.length / 2,\n                        z * this.spacing - this.length / 2\n                    );\n                    //this.group.add(voxel.group);\n                }\n            }\n        }\n\n        this.shellGeometry = new BoxGeometry(this.voxelSize, this.voxelSize, this.voxelSize);\n        this.shellMaterial = new MeshBasicMaterial({\n            color: new Color('#111111'),\n            side: BackSide\n        })\n        this.shellsMesh = new InstancedMesh(this.shellGeometry, this.shellMaterial, this.volume);\n        this.shellsMesh.renderOrder = 0;\n        this.group.add(this.shellsMesh);\n\n        this.highlightGeometry = new BoxGeometry(this.voxelSize, this.voxelSize, this.voxelSize);\n        this.highlightMaterial = new MeshBasicMaterial({\n            color: new Color('#ffffff'),\n            side: BackSide\n        })\n        this.highlightMesh = new InstancedMesh(this.highlightGeometry, this.highlightMaterial, this.volume);\n        this.highlightMesh.renderOrder = 1;\n        this.group.add(this.highlightMesh);\n\n        for (let x = 0; x < this.size; x++) {\n            for (let y = 0; y < this.size; y++) {\n                for (let z = 0; z < this.size; z++) {\n                    const id = x + y * this.size + z * (this.size * this.size);\n                    this.shellsMesh.setMatrixAt(\n                        id,\n                        new Matrix4().makeTranslation(\n                            -(x * this.spacing - this.length / 2),\n                            -(y * this.spacing - this.length / 2),\n                            -(z * this.spacing - this.length / 2)\n                        ),\n                    );\n\n                    this.highlightMesh.setMatrixAt(\n                        id,\n                        new Matrix4()\n                            .makeTranslation(\n                                -(x * this.spacing - this.length / 2) - 0.01,\n                                -(y * this.spacing - this.length / 2) - 0.01,\n                                -(z * this.spacing - this.length / 2) - 0.01\n                            )\n                            .scale(\n                                new Vector3(1.05, 1.05, 1.05)\n                            ),\n                    );\n                }\n            }\n        }\n\n        this.guidelines = new Guidelines(this.length, this.voxelSize, this.spacing);\n        //this.group.add(this.guidelines.segments);\n    }\n\n    addTracer(tracer: Tracer) {\n        this.tracers.push(tracer);\n        this.group.add(tracer.group);\n    }\n\n    update(delta: number) {\n        if (this.tracerSpawnCounter++ > this.tracerSpawnThreshold) {\n            const team = Team.fromID(randomInt(0, Team.count()))!;\n            const health = randomInt(1, MAXIMUM_HEALTH);\n\n            const steps = new Array<PathStep>();\n            const start = new Vector3(0, 0, 0);\n            const curr = new Vector3(0, 0, 0);\n\n            for (let i = 0; i < 32; i++) {\n                let direction = Direction.UP;\n                switch (randomInt(0, 6)) {\n                    case 0:\n                        direction = Direction.UP;\n                        break;\n                    case 1:\n                        direction = Direction.DOWN;\n                        break;\n                    case 2:\n                        direction = Direction.LEFT;\n                        break;\n                    case 3:\n                        direction = Direction.RIGHT;\n                        break;\n                    case 4:\n                        direction = Direction.FORWARD;\n                        break;\n                    case 5:\n                        direction = Direction.BACK;\n                        break;\n                }\n\n                const v = new Vector3().copy(direction.vector).multiplyScalar(this.spacing);\n                const dest = new Vector3().copy(curr).add(v)\n\n                if (dest.x < -this.length / 2 || dest.x > +this.length / 2 ||\n                    dest.y < -this.length / 2 || dest.y > +this.length / 2 ||\n                    dest.z < -this.length / 2 || dest.z > +this.length / 2) {\n                    continue;\n                }\n\n                steps.push(new PathStep(direction, this.spacing, 1500));\n                curr.copy(dest);\n            }\n\n            const tracer = new Tracer(\n                team,\n                health,\n                start,\n                new Path(steps),\n            );\n            this.addTracer(tracer);\n\n            this.tracerSpawnThreshold = Math.random() * 64;\n            this.tracerSpawnCounter = 0;\n        }\n\n        const completeTracers: Array<number> = [];\n        for (let i = 0; i < this.tracers.length; i++) {\n            const tracer = this.tracers[i];\n\n            tracer.update(delta);\n\n            if (tracer.hasReachedVoxel()) {\n                const voxel = this.getVoxelFromWorldCoordinates(tracer.position);\n                const overflow = voxel.damage(tracer.health, tracer.shellMaterial.color);\n                tracer.damage(overflow);\n            }\n\n            if (tracer.dead()) {\n                this.group.remove(tracer.group);\n                completeTracers.push(i);\n            }\n        }\n\n        for (let i = completeTracers.length - 1; i >= 0; i--) {\n            this.tracers.splice(completeTracers[i], 1);\n        }\n    }\n\n    getVoxelFromWorldCoordinates({x, y, z}: Vector3): Voxel {\n        return this.getVoxel({\n            x: (x + this.length / 2) / this.spacing,\n            y: (y + this.length / 2) / this.spacing,\n            z: (z + this.length / 2) / this.spacing\n        });\n    }\n\n    /**\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    getVoxel({x, y, z}: Point): Voxel {\n        return this.voxels[x][y][z];\n    }\n}\n\nexport class Guidelines extends SceneNode {\n    readonly material: Material;\n    readonly segments: LineSegments;\n\n    constructor(length: number, voxelSize: number, spacing: number) {\n        super();\n\n        this.material = new LineBasicMaterial({\n            color: new Color('#ffffff'),\n        });\n\n        const halfLength = length / 2;\n\n        const points = new Array<Vector3>();\n        for (let a = -halfLength; a <= halfLength; a += spacing) {\n            for (let b = -halfLength; b <= halfLength; b += spacing) {\n                for (let c = -halfLength; c < halfLength; c += spacing) {\n                    const gapStart = c + voxelSize / 2;\n                    const gapEnd = c + spacing - voxelSize / 2;\n\n                    const gapLength = gapEnd - gapStart;\n                    const len = gapLength * 0.10;\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapStart,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapStart + len,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapEnd - len,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapEnd,\n                    ));\n\n\n                    points.push(new Vector3(\n                        a,\n                        gapStart,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        gapStart + len,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        gapEnd - len,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        gapEnd,\n                        b,\n                    ));\n\n\n                    points.push(new Vector3(\n                        gapStart,\n                        a,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        gapStart + len,\n                        a,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        gapEnd - len,\n                        a,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        gapEnd,\n                        a,\n                        b,\n                    ));\n                }\n            }\n        }\n\n        this.segments = new LineSegments(new BufferGeometry().setFromPoints(points), this.material);\n        this.segments.computeLineDistances();\n        this.group.add(this.segments);\n    }\n}","import {AmbientLight, Color, PerspectiveCamera, PointLight, Scene, WebGLRenderer} from \"three\";\nimport {Lattice} from \"./lattice\";\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\nimport {EffectComposer} from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport {RenderPass} from \"three/examples/jsm/postprocessing/RenderPass\";\n\nexport default class Game {\n    private renderer: WebGLRenderer;\n    private effects: EffectComposer;\n    private camera: PerspectiveCamera;\n    private controls: OrbitControls;\n    private scene: Scene;\n    private ambient: AmbientLight;\n    private sun: PointLight;\n    private lattice: Lattice;\n\n    constructor(private canvas: HTMLCanvasElement) {\n        this.renderer = new WebGLRenderer({\n            canvas: this.canvas,\n            antialias: true,\n        });\n        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);\n\n        this.camera = new PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 1, 2000);\n        this.controls = new OrbitControls(this.camera, this.canvas);\n\n        this.controls.maxPolarAngle = Math.PI / 2;\n\n        this.controls.dampingFactor = 0.025;\n        this.controls.enableDamping = true;\n\n        this.camera.position.set(400, 400, 400);\n        this.controls.update();\n\n        this.scene = new Scene();\n        this.scene.background = new Color('#000000');\n\n        this.ambient = new AmbientLight('#ffffff', 1.0);\n        this.scene.add(this.ambient);\n\n        this.sun = new PointLight('#ffffff', 0.5);\n        this.sun.position.set(800, 800, 800);\n        this.scene.add(this.sun);\n\n        this.lattice = new Lattice(9, 16, 100);\n\n        this.scene.add(this.lattice.group);\n\n        this.effects = new EffectComposer(this.renderer);\n        this.effects.addPass(new RenderPass(this.scene, this.camera));\n    }\n\n    draw(delta: number) {\n        this.lattice.update(delta);\n\n        // TODO(271): Only call this when the element has been resized.\n        this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n        this.camera.updateProjectionMatrix();\n\n        // TODO(271): Only call this when the element has been resized.\n        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\n\n        this.controls.update();\n        this.effects.render();\n    }\n}","import React from 'react';\nimport './Display.css';\nimport Game from \"./game/game\";\n\nexport default class Display extends React.Component<{}, {}>{\n    private ref = React.createRef<HTMLCanvasElement>();\n    private game?: Game;\n\n    constructor(props: {}) {\n        super(props);\n    }\n\n    componentDidMount() {\n        if (this.ref.current) {\n            this.game = new Game(this.ref.current);\n        }\n\n        let previousTime = performance.now();\n        const draw = (currentTime: number) => {\n            if (this.game) {\n                this.game.draw(currentTime - previousTime);\n            }\n            previousTime = currentTime;\n            requestAnimationFrame(draw);\n        };\n\n        requestAnimationFrame(draw);\n    }\n\n    render() {\n        return (\n            <canvas className=\"stretch\" ref={this.ref}>\n\n            </canvas>\n        );\n    }\n}","import React from 'react';\nimport './App.css';\nimport Display from \"./Display\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Display/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}