{"version":3,"sources":["geometry-cache.ts","game/scene-node.ts","game/voxel.ts","game/tracer.ts","game/lattice.ts","game/game.ts","Display.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["SPHERE_GEOMETRIES","Map","getCachedSphereGeometry","radius","has","get","geometry","SphereGeometry","set","BOX_GEOMETRIES","getCachedBoxGeometry","size","BoxGeometry","GRADIENT_MAPS","getCachedGradientMap","tones","texels","Uint8Array","i","length","texture","DataTexture","LuminanceFormat","minFilter","NearestFilter","magFilter","generateMipmaps","SceneNode","group","Group","this","position","Voxel","color","gradientTones","highlightColor","highlightScalar","dotRadius","shellGeometry","shellMaterial","shellMesh","highlightGeometry","highlightMaterial","highlightMesh","dotGeometry","dotMaterial","dotMesh","health","MeshToonMaterial","gradientMap","side","BackSide","Mesh","renderOrder","add","scale","multiplyScalar","Color","visible","amount","equals","overflow","copy","Math","floor","Tracer","outlineGeometry","outlineMaterial","outlineMesh","alpha","accumulatedTime","pathSource","pathPoints","Array","easing","k","base","t","exp","correction","MathUtils","clamp","sigmoid","hue","random","setHSL","FrontSide","MeshPhongMaterial","steps","current","Vector3","step","x","y","z","push","delta","destination","lerpVectors","shift","Lattice","voxelSize","spacing","voxels","guidelines","tracers","tracerSpawnThreshold","tracerSpawnCounter","voxel","Guidelines","segments","tracer","addTracer","completeTracers","update","reachedVoxel","getVoxelFromWorldCoordinates","damage","done","remove","splice","getVoxel","material","LineDashedMaterial","dashSize","gapSize","halfLength","points","a","b","c","LineSegments","BufferGeometry","setFromPoints","computeLineDistances","Game","canvas","renderer","effects","camera","controls","scene","ambient","sun","lattice","WebGLRenderer","antialias","setSize","clientWidth","clientHeight","PerspectiveCamera","OrbitControls","maxPolarAngle","PI","dampingFactor","enableDamping","Scene","background","AmbientLight","PointLight","EffectComposer","addPass","RenderPass","aspect","updateProjectionMatrix","render","Display","props","ref","React","createRef","game","previousTime","performance","now","requestAnimationFrame","draw","currentTime","className","Component","App","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.d60d9701.chunk.js","sourcesContent":["import {\n    BoxGeometry,\n    DataTexture,\n    EdgesGeometry,\n    Geometry,\n    LuminanceFormat,\n    NearestFilter,\n    SphereGeometry,\n    Texture\n} from \"three\";\n\nconst SPHERE_GEOMETRIES = new Map<number, Geometry>();\n\nexport const getCachedSphereGeometry = (radius: number): Geometry => {\n    if (SPHERE_GEOMETRIES.has(radius)) {\n        return SPHERE_GEOMETRIES.get(radius)!;\n    }\n\n    const geometry = new SphereGeometry(radius, 10, 10);\n    SPHERE_GEOMETRIES.set(radius, geometry);\n    return geometry;\n}\n\nconst BOX_GEOMETRIES = new Map<number, Geometry>();\n\nexport const getCachedBoxGeometry = (size: number): Geometry => {\n    if (BOX_GEOMETRIES.has(size)) {\n        return BOX_GEOMETRIES.get(size)!;\n    }\n\n    const geometry = new BoxGeometry(size, size, size);\n    BOX_GEOMETRIES.set(size, geometry);\n    return geometry;\n}\n\nconst EDGE_GEOMETRIES = new Map<number, EdgesGeometry>();\n\nexport const getCachedEdgesGeometry = (size: number): EdgesGeometry => {\n    if (EDGE_GEOMETRIES.has(size)) {\n        return EDGE_GEOMETRIES.get(size)!;\n    }\n\n    const geometry = new EdgesGeometry(getCachedBoxGeometry(size));\n    EDGE_GEOMETRIES.set(size, geometry);\n    return geometry;\n}\n\nconst GRADIENT_MAPS = new Map<number, Texture>();\n\nexport const getCachedGradientMap = (tones: number): Texture => {\n    if (GRADIENT_MAPS.has(tones)) {\n        return GRADIENT_MAPS.get(tones)!;\n    }\n\n    const texels = new Uint8Array( tones);\n    for (let i = 0; i <= texels.length; i ++ ) {\n        texels[i] = (i / texels.length) * 0x100;\n    }\n\n    const texture = new DataTexture(texels, texels.length, 1, LuminanceFormat);\n    texture.minFilter = NearestFilter;\n    texture.magFilter = NearestFilter;\n    texture.generateMipmaps = false;\n    GRADIENT_MAPS.set(tones, texture);\n\n    return texture;\n}","import {Group, Vector3} from \"three\";\n\nexport default abstract class SceneNode {\n    readonly group: Group = new Group();\n\n    get position(): Vector3 {\n        return this.group.position;\n    }\n}","import {\n    BackSide,\n    BoxGeometry,\n    Color, DataTexture,\n    EdgesGeometry, Geometry, Group,\n    LineBasicMaterial,\n    LineSegments,\n    LuminanceFormat, Material,\n    Mesh, MeshPhongMaterial,\n    MeshToonMaterial,\n    NearestFilter, OctahedronGeometry,\n    Texture\n} from 'three';\nimport {\n    getCachedSphereGeometry,\n    getCachedEdgesGeometry,\n    getCachedGradientMap,\n    getCachedBoxGeometry\n} from \"../geometry-cache\";\nimport SceneNode from \"./scene-node\";\n\nexport interface VoxelParameters {\n    readonly color: Color;\n    readonly size: number;\n    readonly gradientTones: number;\n    readonly highlight: VoxelHighlightParameters;\n}\n\nexport interface VoxelHighlightParameters {\n    readonly color: Color;\n    readonly scalar: number;\n}\n\n/**\n * A voxel is a\n */\nexport class Voxel extends SceneNode {\n    readonly shellGeometry: Geometry;\n    readonly shellMaterial: MeshToonMaterial;\n    readonly shellMesh: Mesh;\n\n    readonly highlightGeometry: Geometry;\n    readonly highlightMaterial: MeshToonMaterial;\n    readonly highlightMesh: Mesh;\n\n    readonly dotGeometry: Geometry;\n    readonly dotMaterial: MeshToonMaterial;\n    readonly dotMesh: Mesh;\n\n    health: number = 0;\n\n    constructor(\n        size: number,\n        color: Color,\n        gradientTones: number,\n        highlightColor: Color,\n        highlightScalar: number,\n        dotRadius: number,\n    ) {\n        super();\n\n        this.shellGeometry = getCachedBoxGeometry(size);\n        this.shellMaterial = new MeshToonMaterial({\n            color: color,\n            gradientMap: getCachedGradientMap(gradientTones),\n            side: BackSide\n        });\n        this.shellMesh = new Mesh(this.shellGeometry, this.shellMaterial);\n        this.shellMesh.renderOrder = 1;\n        this.group.add(this.shellMesh);\n\n        this.highlightGeometry = getCachedBoxGeometry(size);\n        this.highlightMaterial = new MeshToonMaterial({\n            color: highlightColor,\n            gradientMap: getCachedGradientMap(gradientTones),\n            side: BackSide\n        });\n        this.highlightMesh = new Mesh(this.highlightGeometry, this.highlightMaterial);\n        this.highlightMesh.scale.multiplyScalar(highlightScalar);\n        this.highlightMesh.renderOrder = 0;\n        this.group.add(this.highlightMesh);\n\n        this.dotGeometry = getCachedSphereGeometry(dotRadius);\n        this.dotMaterial = new MeshToonMaterial({\n            color: new Color('#ff0000'),\n            gradientMap: getCachedGradientMap(gradientTones),\n        });\n        this.dotMesh = new Mesh(this.dotGeometry, this.dotMaterial);\n        this.dotMesh.scale.multiplyScalar(1.1);\n        this.dotMesh.visible = false;\n        this.dotMesh.renderOrder = 2;\n        this.group.add(this.dotMesh);\n    }\n\n    damage(amount: number, color: Color): number {\n        if (this.dotMaterial.color.equals(color)) {\n            return 0;\n        }\n\n        let overflow: number = 0;\n\n        if (this.health === 0) {\n            if (amount === 1) {\n                this.dotMaterial.color = new Color().copy(color);\n                this.dotMesh.visible = true;\n                this.health = 1;\n                overflow = 1;\n            } else {\n                this.dotMaterial.color = new Color().copy(color);\n                this.dotMesh.visible = true;\n                this.health = Math.floor(amount / 2);\n                overflow = amount - this.health;\n            }\n        } else if (this.health - amount < 0) {\n            this.dotMaterial.color = new Color().copy(color);\n            this.dotMesh.visible = true;\n            this.health = Math.floor((amount - this.health) / 2);\n            overflow = amount - this.health;\n        } else if(this.health - amount === 0) {\n            this.dotMaterial.color = new Color().copy(this.shellMaterial.color);\n            this.dotMesh.visible = false;\n            this.health = 0;\n            overflow = this.health;\n        } else {\n            this.health -= amount;\n            overflow = amount;\n        }\n\n        const scale = Math.floor((this.health + 100) / 100) / 6;\n        this.dotMesh.scale.set(1, 1, 1).multiplyScalar(scale).multiplyScalar(1.1);\n\n        return overflow;\n    }\n}","import {\n    BackSide,\n    Color, DataTexture, FrontSide, Geometry,\n    Group, LuminanceFormat, Material, MathUtils,\n    Mesh,\n    MeshBasicMaterial,\n    MeshPhongMaterial, MeshToonMaterial, NearestFilter, OctahedronGeometry,\n    PointLight,\n    SphereGeometry,\n    Vector3\n} from \"three\";\nimport {getCachedGradientMap, getCachedSphereGeometry} from \"../geometry-cache\";\nimport SceneNode from \"./scene-node\";\n\nconst sigmoid = (k: number) => {\n    const base = (t: number) => {\n        return (1 / (1 + Math.exp(-k * t))) - 0.5;\n    }\n\n    const correction = 0.5 / base(1);\n\n    return function (t: number): number {\n        t = MathUtils.clamp(t, 0, 1);\n        return correction * base(2 * t - 1) + 0.5;\n    };\n}\n\nexport default class Tracer extends SceneNode {\n\n    readonly shellGeometry: Geometry;\n    readonly shellMaterial: MeshToonMaterial;\n    readonly shellMesh: Mesh;\n\n    readonly outlineGeometry: Geometry;\n    readonly outlineMaterial: MeshPhongMaterial;\n    readonly outlineMesh: Mesh;\n\n    private alpha: number = 0;\n    private accumulatedTime: number = 0;\n    private pathSource: Vector3;\n    private pathPoints: Vector3[] = new Array<Vector3>();\n    private easing: (t: number) => number = sigmoid(5.5);\n\n    constructor(public health: number, readonly radius: number) {\n        super();\n\n        const hue = Math.floor(Math.random() * 6) / 5;\n        const scale = Math.floor((this.health + 100) / 100) / 6;\n\n        this.group.scale.multiplyScalar(scale);\n\n        this.shellGeometry = getCachedSphereGeometry(radius);\n        this.shellMaterial = new MeshToonMaterial({\n            color: new Color().setHSL(hue, 0.25, 0.5),\n            gradientMap: getCachedGradientMap(10), side: FrontSide\n        });\n        this.shellMesh = new Mesh(this.shellGeometry, this.shellMaterial);\n        this.shellMesh.renderOrder = 1;\n        this.group.add(this.shellMesh);\n\n        this.outlineGeometry = getCachedSphereGeometry(radius);\n        this.outlineMaterial = new MeshPhongMaterial({color: new Color().setHSL(hue, 0.25, 0.3), side: BackSide});\n        this.outlineMesh = new Mesh(this.outlineGeometry, this.outlineMaterial);\n        this.outlineMesh.scale.multiplyScalar(1.05);\n        this.outlineMesh.renderOrder = 0;\n        this.group.add(this.outlineMesh);\n\n        // TODO: Remove this all, eventually.\n        const halfLength = (900 - 100) / 2;\n        const steps = Math.floor(Math.random() * 32 + 1);\n        const current = new Vector3(0, 0, 0);\n        for (let step = 0; step < steps; step++) {\n            const direction = Math.floor(Math.random() * 6);\n            switch (direction) {\n                case 0:\n                    current.add(new Vector3(100, 0, 0));\n                    break;\n                case 1:\n                    current.add(new Vector3(-100, 0, 0));\n                    break;\n                case 2:\n                    current.add(new Vector3(0, 100, 0));\n                    break;\n                case 3:\n                    current.add(new Vector3(0, -100, 0));\n                    break;\n                case 4:\n                    current.add(new Vector3(0, 0, 100));\n                    break;\n                case 5:\n                    current.add(new Vector3(0, 0, -100));\n                    break;\n            }\n\n            if (current.x > +halfLength || current.y > +halfLength || current.z > +halfLength ||\n                current.x < -halfLength || current.y < -halfLength || current.z < -halfLength) {\n                continue;\n            }\n\n            this.pathPoints.push(new Vector3().copy(current));\n        }\n\n        this.pathSource = new Vector3(0, 0, 0);\n        this.group.position.copy(this.pathSource);\n    }\n\n    update(delta: number) {\n        if (this.pathPoints.length > 0) {\n            const destination = this.pathPoints[0];\n\n            this.accumulatedTime += delta;\n\n            this.alpha = this.easing(this.accumulatedTime / 1500);\n            if (this.alpha > 1) {\n                this.alpha = 1;\n            }\n\n            this.group.position.copy(new Vector3().lerpVectors(this.pathSource, destination, this.alpha));\n\n            if (this.alpha === 1.0) {\n                this.pathSource = this.pathPoints.shift()!;\n                this.alpha = 0;\n                this.accumulatedTime = 0;\n            }\n        }\n    }\n\n    damage(amount: number) {\n        this.health -= amount;\n        if (this.health < 0) {\n            this.health = 0;\n        }\n\n        if (this.health !== 0) {\n            const scale = Math.floor((this.health + 100) / 100) / 6;\n            this.group.scale.set(1, 1, 1).multiplyScalar(scale);\n        }\n    }\n\n    reachedVoxel(): boolean {\n        return this.alpha === 0;\n    }\n\n    done() : boolean {\n        return this.health === 0 || this.pathPoints.length === 0;\n    }\n}\n\n","import {Voxel, VoxelParameters} from './voxel';\nimport {BufferGeometry, Color, Group, LineDashedMaterial, LineSegments, Material, Scene, Vector3} from \"three\";\nimport {Point} from \"./point\";\nimport Tracer from \"./tracer\";\nimport SceneNode from \"./scene-node\";\n\nexport class Lattice extends SceneNode {\n    readonly length: number;\n    readonly voxels: Voxel[][][];\n    readonly guidelines: Guidelines;\n    readonly tracers: Tracer[] = new Array<Tracer>();\n\n    // TODO: Remove.\n    private tracerSpawnThreshold: number = 300;\n    private tracerSpawnCounter: number = 0;\n\n    constructor(\n        readonly size: number,\n        readonly voxelSize: number,\n        readonly spacing: number\n    ) {\n        super();\n\n        this.length = (this.size - 1) * this.spacing;\n\n        this.voxels = new Array<Array<Array<Voxel>>>(this.size);\n        for (let x = 0; x < this.size; x++) {\n            this.voxels[x] = new Array<Array<Voxel>>(this.size);\n            for (let y = 0; y < this.size; y++) {\n                this.voxels[x][y] = new Array<Voxel>(this.size);\n            }\n        }\n\n        for (let x = 0; x < this.size; x++) {\n            for (let y = 0; y < this.size; y++) {\n                for (let z = 0; z < this.size; z++) {\n                    const voxel = this.voxels[x][y][z] = new Voxel(\n                        voxelSize,\n                        new Color('#111111'),\n                        5,\n                        new Color('#ffffff'),\n                        1.05,\n                        6\n                    );\n\n                    voxel.group.position.set(\n                        x * this.spacing - this.length / 2,\n                        y * this.spacing - this.length / 2,\n                        z * this.spacing - this.length / 2\n                    );\n                    this.group.add(voxel.group);\n                }\n            }\n        }\n\n        this.guidelines = new Guidelines(this.length, this.voxelSize, this.spacing);\n        this.group.add(this.guidelines.segments);\n    }\n\n    addTracer(tracer: Tracer) {\n        this.tracers.push(tracer);\n        this.group.add(tracer.group);\n    }\n\n    update(delta: number) {\n        if (this.tracerSpawnCounter++ > this.tracerSpawnThreshold) {\n            const health = Math.floor(Math.random() * 500) + 1;\n            const tracer = new Tracer(health, 6);\n            this.addTracer(tracer);\n\n            this.tracerSpawnThreshold = Math.random() * 64;\n            this.tracerSpawnCounter = 0;\n        }\n\n        const completeTracers: Array<number> = [];\n        for (let i = 0; i < this.tracers.length; i++) {\n            const tracer = this.tracers[i];\n\n            tracer.update(delta);\n\n            if (tracer.reachedVoxel()) {\n                const voxel = this.getVoxelFromWorldCoordinates(tracer.position);\n                const overflow = voxel.damage(tracer.health, tracer.shellMaterial.color);\n                tracer.damage(overflow);\n            }\n\n            if (tracer.done()) {\n                this.group.remove(tracer.group);\n                completeTracers.push(i);\n            }\n        }\n\n        for (let i = completeTracers.length - 1; i >= 0; i--) {\n            this.tracers.splice(completeTracers[i], 1);\n        }\n    }\n\n    getVoxelFromWorldCoordinates({x, y, z}: Vector3): Voxel {\n        return this.getVoxel({\n            x: (x + this.length / 2) / this.spacing,\n            y: (y + this.length / 2) / this.spacing,\n            z: (z + this.length / 2) / this.spacing\n        });\n    }\n\n    /**\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    getVoxel({x, y, z}: Point): Voxel {\n        return this.voxels[x][y][z];\n    }\n}\n\nexport class Guidelines extends SceneNode {\n    readonly material: Material;\n    readonly segments: LineSegments;\n\n    constructor(length: number, voxelSize: number, spacing: number) {\n        super();\n\n        this.material = new LineDashedMaterial({\n            color: new Color('#aaaaaa'),\n            dashSize: 5,\n            gapSize: 2,\n        });\n\n        const halfLength = length / 2;\n\n        const points = new Array<Vector3>();\n        for (let a = -halfLength; a <= halfLength; a += spacing) {\n            for (let b = -halfLength; b <= halfLength; b += spacing) {\n                for (let c = -halfLength; c < halfLength; c += spacing) {\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        c + voxelSize / 2,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        c + spacing - voxelSize / 2,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        c + voxelSize / 2,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        c + spacing - voxelSize / 2,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        c + voxelSize / 2,\n                        a,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        c + spacing - voxelSize / 2,\n                        a,\n                        b,\n                    ));\n                }\n            }\n        }\n\n        this.segments = new LineSegments(new BufferGeometry().setFromPoints(points), this.material);\n        this.segments.computeLineDistances();\n        this.group.add(this.segments);\n    }\n}","import {AmbientLight, Color, PerspectiveCamera, PointLight, Scene, WebGLRenderer} from \"three\";\nimport {Lattice} from \"./lattice\";\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\nimport {EffectComposer} from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport {RenderPass} from \"three/examples/jsm/postprocessing/RenderPass\";\n\nexport default class Game {\n    private renderer: WebGLRenderer;\n    private effects: EffectComposer;\n    private camera: PerspectiveCamera;\n    private controls: OrbitControls;\n    private scene: Scene;\n    private ambient: AmbientLight;\n    private sun: PointLight;\n    private lattice: Lattice;\n\n    constructor(private canvas: HTMLCanvasElement) {\n        this.renderer = new WebGLRenderer({\n            canvas: this.canvas,\n            antialias: true,\n        });\n        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);\n\n        this.camera = new PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 1, 8000);\n        this.controls = new OrbitControls(this.camera, this.canvas);\n\n        this.controls.maxPolarAngle = Math.PI / 2;\n\n        this.controls.dampingFactor = 0.025;\n        this.controls.enableDamping = true;\n\n        this.camera.position.set(400, 400, 400);\n        this.controls.update();\n\n        this.scene = new Scene();\n        this.scene.background = new Color('#000000');\n\n        this.ambient = new AmbientLight('#ffffff', 1.0);\n        this.scene.add(this.ambient);\n\n        this.sun = new PointLight('#ffffff', 0.5);\n        this.sun.position.set(800, 800, 800);\n        this.scene.add(this.sun);\n\n        this.lattice = new Lattice(9, 16, 100);\n\n        this.scene.add(this.lattice.group);\n\n        this.effects = new EffectComposer(this.renderer);\n        this.effects.addPass(new RenderPass(this.scene, this.camera));\n    }\n\n    draw(delta: number) {\n        this.lattice.update(delta);\n\n        // TODO(271): Only call this when the element has been resized.\n        this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n        this.camera.updateProjectionMatrix();\n\n        // TODO(271): Only call this when the element has been resized.\n        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\n\n        this.controls.update();\n        this.effects.render();\n    }\n}","import React from 'react';\nimport './Display.css';\nimport Game from \"./game/game\";\n\nexport default class Display extends React.Component<{}, {}>{\n    private ref = React.createRef<HTMLCanvasElement>();\n    private game?: Game;\n\n    constructor(props: {}) {\n        super(props);\n    }\n\n    componentDidMount() {\n        if (this.ref.current) {\n            this.game = new Game(this.ref.current);\n        }\n\n        let previousTime = performance.now();\n        const draw = (currentTime: number) => {\n            if (this.game) {\n                this.game.draw(currentTime - previousTime);\n            }\n            previousTime = currentTime;\n            requestAnimationFrame(draw);\n        };\n\n        requestAnimationFrame(draw);\n    }\n\n    render() {\n        return (\n            <canvas className=\"stretch\" ref={this.ref}>\n\n            </canvas>\n        );\n    }\n}","import React from 'react';\nimport './App.css';\nimport Display from \"./Display\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Display/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}