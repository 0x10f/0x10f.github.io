{"version":3,"sources":["game/geometry-cache.ts","game/scene-node.ts","game/voxel.ts","game/health.ts","game/utils.ts","game/tracer.ts","game/team.ts","game/lattice.ts","game/game.ts","Display.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["SPHERE_GEOMETRIES","Map","getCachedSphereGeometry","radius","has","get","geometry","SphereGeometry","set","GRADIENT_MAPS","getCachedGradientMap","tones","texels","Uint8Array","i","length","texture","DataTexture","LuminanceFormat","minFilter","NearestFilter","magFilter","generateMipmaps","SceneNode","group","Group","this","position","scale","Voxel","size","color","gradientTones","highlightColor","highlightScalar","dotRadius","dotGeometry","dotMaterial","dotMesh","team","health","MeshToonMaterial","Color","gradientMap","Mesh","multiplyScalar","visible","renderOrder","add","amount","id","overflow","copy","Math","floor","healthToScalar","MAXIMUM_HEALTH","darkenColor","delta","getHSL","h","s","l","setHSL","randomInt","min","max","random","Tracer","start","path","shellGeometry","shellMaterial","shellMesh","outlineGeometry","outlineMaterial","outlineMesh","alpha","stepTime","stepSource","Vector3","easing","sigmoid","side","FrontSide","MeshPhongMaterial","BackSide","complete","step","peek","dest","addVectors","time","lerpVectors","poll","Path","steps","index","PathStep","direction","distance","vector","Direction","UP","DOWN","LEFT","RIGHT","FORWARD","BACK","k","base","t","exp","correction","MathUtils","clamp","Team","ALL","TEAM_A","TEAM_B","TEAM_C","TEAM_D","Lattice","voxelSize","spacing","volume","voxels","guidelines","tracers","Array","tracerSpawnThreshold","tracerSpawnCounter","shellsMesh","highlightGeometry","highlightMaterial","highlightMesh","x","y","z","voxel","BoxGeometry","MeshBasicMaterial","InstancedMesh","setMatrixAt","Matrix4","makeTranslation","Guidelines","tracer","push","fromID","count","curr","v","addTracer","completeTracers","update","hasReachedVoxel","getVoxelFromWorldCoordinates","damage","dead","remove","splice","getVoxel","material","segments","LineBasicMaterial","halfLength","points","a","b","c","gapStart","gapEnd","len","LineSegments","BufferGeometry","setFromPoints","computeLineDistances","Game","canvas","renderer","effects","camera","controls","scene","ambient","sun","lattice","WebGLRenderer","antialias","setSize","clientWidth","clientHeight","PerspectiveCamera","OrbitControls","maxPolarAngle","PI","dampingFactor","enableDamping","Scene","background","AmbientLight","PointLight","EffectComposer","addPass","RenderPass","aspect","updateProjectionMatrix","render","Display","props","ref","React","createRef","game","current","previousTime","performance","now","requestAnimationFrame","draw","currentTime","className","Component","App","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"kUAWMA,EAAoB,IAAIC,IAEjBC,EAA0B,SAACC,GACpC,GAAIH,EAAkBI,IAAID,GACtB,OAAOH,EAAkBK,IAAIF,GAGjC,IAAMG,EAAW,IAAIC,IAAeJ,GAEpC,OADAH,EAAkBQ,IAAIL,EAAQG,GACvBA,GA2BLG,GAxBiB,IAAIR,IAYH,IAAIA,IAYN,IAAIA,KAEbS,EAAuB,SAACC,GACjC,GAAIF,EAAcL,IAAIO,GAClB,OAAOF,EAAcJ,IAAIM,GAI7B,IADA,IAAMC,EAAS,IAAIC,WAAYF,GACtBG,EAAI,EAAGA,GAAKF,EAAOG,OAAQD,IAChCF,EAAOE,GAAMA,EAAIF,EAAOG,OAAU,IAGtC,IAAMC,EAAU,IAAIC,IAAYL,EAAQA,EAAOG,OAAQ,EAAGG,KAM1D,OALAF,EAAQG,UAAYC,IACpBJ,EAAQK,UAAYD,IACpBJ,EAAQM,iBAAkB,EAC1Bb,EAAcD,IAAIG,EAAOK,GAElBA,GC/DmBO,E,iDACjBC,MAAe,IAAIC,I,qDAGxB,OAAOC,KAAKF,MAAMG,W,4BAIlB,OAAOD,KAAKF,MAAMI,U,KCgBbC,EAAb,kDASI,WACIC,EACAC,EACAC,EACAC,EACAC,EACAC,GACD,IAAD,8BACE,gBAfKC,iBAcP,IAbOC,iBAaP,IAZOC,aAYP,IAVFC,KAAoB,KAUlB,EATFC,OAAiB,EAYb,EAAKJ,YAAclC,EAAwBiC,GAC3C,EAAKE,YAAc,IAAII,IAAiB,CACpCV,MAAO,IAAIW,IAAM,WACjBC,YAAajC,EAAqBsB,KAEtC,EAAKM,QAAU,IAAIM,IAAK,EAAKR,YAAa,EAAKC,aAC/C,EAAKC,QAAQV,MAAMiB,eAAe,KAClC,EAAKP,QAAQQ,SAAU,EACvB,EAAKR,QAAQS,YAAc,EAC3B,EAAKvB,MAAMwB,IAAI,EAAKV,SAZtB,EAhBN,mDA+BWW,EAAgBV,GACnB,GAAkB,OAAdb,KAAKa,MAAiBb,KAAKa,KAAKW,KAAOX,EAAKW,GAC5C,OAAO,EAGX,IAAIC,EAAmB,EAEH,IAAhBzB,KAAKc,QACU,IAAXS,GACAvB,KAAKW,YAAYN,OAAQ,IAAIW,KAAQU,KAAKb,EAAKR,OAC/CL,KAAKY,QAAQQ,SAAU,EACvBpB,KAAKc,OAAS,EACdW,EAAW,IAEXzB,KAAKW,YAAYN,OAAQ,IAAIW,KAAQU,KAAKb,EAAKR,OAC/CL,KAAKY,QAAQQ,SAAU,EACvBpB,KAAKc,OAASa,KAAKC,MAAML,EAAS,GAClCE,EAAWF,EAASvB,KAAKc,QAE7Bd,KAAKa,KAAOA,GACLb,KAAKc,OAASS,EAAS,GAC9BvB,KAAKW,YAAYN,OAAQ,IAAIW,KAAQU,KAAKb,EAAKR,OAC/CL,KAAKY,QAAQQ,SAAU,EACvBpB,KAAKc,OAASa,KAAKC,OAAOL,EAASvB,KAAKc,QAAU,GAClDW,EAAWF,EAASvB,KAAKc,OACzBd,KAAKa,KAAO,MACNb,KAAKc,OAASS,IAAW,GAC/BvB,KAAKW,YAAYN,OAAQ,IAAIW,KAAQU,KAAK,IAAIV,IAAM,YACpDhB,KAAKY,QAAQQ,SAAU,EACvBpB,KAAKc,OAAS,EACdW,EAAWzB,KAAKc,OAChBd,KAAKa,KAAO,OAEZb,KAAKc,QAAUS,EACfE,EAAWF,GAGf,IAAMrB,EAAQyB,KAAKC,OAAO5B,KAAKc,OAAS,KAAO,KAAO,EAGtD,OAFAd,KAAKY,QAAQV,MAAMpB,IAAI,EAAG,EAAG,GAAGqC,eAAejB,GAAOiB,eAAe,KAE9DM,MAvEf,GAA2B5B,GCtBdgC,EAAiB,SAACf,GAE3B,OAAOa,KAAKC,OAAQd,EADVgB,UACH,GCJEC,EAAc,SAAC1B,EAAc2B,GAA0B,IAAD,EAC/C3B,EAAM4B,OAAO,CAACC,EAAG,EAAGC,EAAG,EAAGC,EAAG,IAAxCF,EAD0D,EAC1DA,EAAGC,EADuD,EACvDA,EAAGC,EADoD,EACpDA,EAKX,OAJAA,GAAKJ,GACG,IACJI,EAAI,IAED,IAAIpB,KAAQqB,OAAOH,EAAGC,EAAGC,IAGvBE,EAAY,SAACC,EAAaC,GACnC,OAAOb,KAAKC,MAAMD,KAAKc,UAAYD,EAAMD,IAAQA,GCQhCG,E,kDAsBjB,WACa7B,EACFC,EACE6B,EACAC,GACV,IAAD,8BACE,gBALS/B,OAIX,EAHSC,SAGT,EAFW6B,QAEX,EADWC,OACX,EAzBOC,mBAyBP,IAxBOC,mBAwBP,IAvBOC,eAuBP,IArBOC,qBAqBP,IApBOC,qBAoBP,IAnBOC,iBAmBP,IAjBMC,MAAgB,EAiBtB,EAhBMC,SAAmB,EAgBzB,EAfMC,WAAsB,IAAIC,IAehC,EAdMC,OAAgCC,EAAQ,KAiB5C,EAAKX,cAAgBrE,EAhCN,GAiCf,EAAKsE,cAAgB,IAAI/B,IAAiB,CACtCV,MAAOQ,EAAKR,MACZY,YAAajC,EAAqB,IAClCyE,KAAMC,MAEV,EAAKX,UAAY,IAAI7B,IAAK,EAAK2B,cAAe,EAAKC,eACnD,EAAKC,UAAU1B,YAAc,EAC7B,EAAKvB,MAAMwB,IAAI,EAAKyB,WAEpB,EAAKC,gBAAkBxE,EA1CR,GA2Cf,EAAKyE,gBAAkB,IAAIU,IAAkB,CACzCtD,MAAO0B,EAAY,EAAKlB,KAAKR,MAAO,IACpCoD,KAAMG,MAEV,EAAKV,YAAc,IAAIhC,IAAK,EAAK8B,gBAAiB,EAAKC,iBACvD,EAAKC,YAAYhD,MAAMiB,eAAe,MACtC,EAAK+B,YAAY7B,YAAc,EAC/B,EAAKvB,MAAMwB,IAAI,EAAK4B,aAEpB,EAAKjD,SAASyB,KAAK,EAAK2B,YACxB,EAAKnD,MAAMiB,eAAeU,EAAe,EAAKf,SAE9C,EAAKuC,WAAW3B,KAAK,EAAKiB,OA1B5B,E,mDAkCKpB,GACHvB,KAAKc,QAAUS,EACXvB,KAAKc,OAAS,IACdd,KAAKc,OAAS,GAGE,IAAhBd,KAAKc,QACLd,KAAKF,MAAMI,MAAMpB,IAAI,EAAG,EAAG,GAAGqC,eAAeU,EAAe7B,KAAKc,W,6BAIlEkB,GACH,IAAIhC,KAAK4C,KAAKiB,WAAd,CAIA,IAAMC,EAAO9D,KAAK4C,KAAKmB,OACjBC,GAAO,IAAIV,KAAUW,WACvBjE,KAAKqD,WACLS,EAAK9B,SAGThC,KAAKoD,UAAYpB,EAEjBhC,KAAKmD,MAAQnD,KAAKuD,OAAOvD,KAAKoD,SAAWU,EAAKI,MAC1ClE,KAAKmD,MAAQ,IACbnD,KAAKmD,MAAQ,GAGjBnD,KAAKC,SAASyB,MAAK,IAAI4B,KAAUa,YAAYnE,KAAKqD,WAAYW,EAAMhE,KAAKmD,QAEtD,IAAfnD,KAAKmD,QACLnD,KAAK4C,KAAKwB,OAEVpE,KAAKqD,WAAaW,EAClBhE,KAAKmD,MAAQnD,KAAKoD,SAAW,M,wCAKjC,OAAsB,IAAfpD,KAAKmD,Q,6BAOZ,OAAuB,IAAhBnD,KAAKc,QAAgBd,KAAK4C,KAAKiB,e,GA5GVhE,GAgHvBwE,EAAb,WAGI,WAAqBC,GAAoB,yBAApBA,QAAmB,KAFhCC,MAAQ,EADpB,mDAMQ,OAAOvE,KAAKsE,MAAMtE,KAAKuE,SAN/B,6BAUQ,OAAOvE,KAAKsE,MAAMtE,KAAKuE,WAV/B,iCAcQ,OAAOvE,KAAKuE,QAAUvE,KAAKsE,MAAMjF,WAdzC,KAkBamF,EAAb,WAQI,WAAqBC,EAA+BC,EAA2BR,GAAe,yBAAzEO,YAAwE,KAAzCC,WAAyC,KAAdR,OARnF,oDAYQ,OAAO,IAAIZ,KAAU5B,KAAK1B,KAAKyE,UAAUE,QAAQxD,eAAenB,KAAK0E,cAZ7E,KAgBaE,EAQT,WAA6BD,GAAkB,yBAAlBA,UARpBC,EACKC,GAAK,IAAID,EAAU,IAAItB,IAAQ,EAAG,EAAG,IAD1CsB,EAEKE,KAAO,IAAIF,EAAU,IAAItB,IAAQ,GAAI,EAAG,IAF7CsB,EAGKG,KAAO,IAAIH,EAAU,IAAItB,IAAQ,EAAG,EAAG,IAH5CsB,EAIKI,MAAQ,IAAIJ,EAAU,IAAItB,KAAS,EAAG,EAAG,IAJ9CsB,EAKKK,QAAU,IAAIL,EAAU,IAAItB,IAAQ,EAAG,EAAG,IAL/CsB,EAMKM,KAAO,IAAIN,EAAU,IAAItB,IAAQ,EAAG,GAAI,IAW1D,IAAME,EAAU,SAAC2B,GACb,IAAMC,EAAO,SAACC,GACV,OAAQ,GAAK,EAAI1D,KAAK2D,KAAKH,EAAIE,IAAO,IAGpCE,EAAa,GAAMH,EAAK,GAE9B,OAAO,SAACC,GAEJ,OADAA,EAAIG,IAAUC,MAAMJ,EAAG,EAAG,GACnBE,EAAaH,EAAK,EAAIC,EAAI,GAAK,KC9LjCK,EAAb,WAQI,WAA6BlE,EAAqBnB,GAAe,yBAApCmB,KAAmC,KAAdnB,QAC9CqF,EAAKC,IAAI7G,IAAI0C,EAAIxB,MATzB,wDAYyBwB,GACjB,OAAOkE,EAAKC,IAAIhH,IAAI6C,KAb5B,8BAiBQ,OAAOkE,EAAKC,IAAIvF,SAjBxB,KAAasF,EACMC,IAAM,IAAIpH,IADhBmH,EAGKE,OAAS,IAAIF,EAAK,GAAG,IAAI1E,KAAQqB,OAAO,EAAK,GAAK,KAHvDqD,EAIKG,OAAS,IAAIH,EAAK,GAAG,IAAI1E,KAAQqB,OAAO,GAAK,GAAK,KAJvDqD,EAKKI,OAAS,IAAIJ,EAAK,GAAG,IAAI1E,KAAQqB,OAAO,GAAK,GAAK,KALvDqD,EAMKK,OAAS,IAAIL,EAAK,GAAG,IAAI1E,KAAQqB,OAAO,GAAK,GAAK,KCa7D,IAAM2D,EAAb,kDAmBI,WACa5F,EACA6F,EACAC,GACV,IAAD,uBACE,gBAJS9F,OAGX,EAFW6F,YAEX,EADWC,UACX,EAtBOC,YAsBP,IArBO9G,YAqBP,IApBO+G,YAoBP,IAnBOC,gBAmBP,IAlBOC,QAAoB,IAAIC,MAkB/B,EAfMC,qBAA+B,IAerC,EAdMC,mBAA6B,EAcnC,EAZM5D,mBAYN,IAXMC,mBAWN,IAVM4D,gBAUN,IARMC,uBAQN,IAPMC,uBAON,IANMC,mBAMN,EAGE,EAAKV,OAAS,EAAK/F,KAAO,EAAKA,KAAO,EAAKA,KAE3C,EAAKf,QAAU,EAAKe,KAAO,GAAK,EAAK8F,QAErC,EAAKE,OAAS,IAAIG,MAA2B,EAAKnG,MAClD,IAAK,IAAI0G,EAAI,EAAGA,EAAI,EAAK1G,KAAM0G,IAAK,CAChC,EAAKV,OAAOU,GAAK,IAAIP,MAAoB,EAAKnG,MAC9C,IAAK,IAAI2G,EAAI,EAAGA,EAAI,EAAK3G,KAAM2G,IAC3B,EAAKX,OAAOU,GAAGC,GAAK,IAAIR,MAAa,EAAKnG,MAIlD,IAAK,IAAI0G,EAAI,EAAGA,EAAI,EAAK1G,KAAM0G,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAK3G,KAAM2G,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAK5G,KAAM4G,IAAK,CAChC,IAAMC,EAAQ,EAAKb,OAAOU,GAAGC,GAAGC,GAAK,IAAI7G,EACrC8F,EACA,IAAIjF,IAAM,WACV,EACA,IAAIA,IAAM,WACV,KACA,GAGJiG,EAAMnH,MAAMG,SAASnB,IACjBgI,EAAI,EAAKZ,QAAU,EAAK7G,OAAS,EACjC0H,EAAI,EAAKb,QAAU,EAAK7G,OAAS,EACjC2H,EAAI,EAAKd,QAAU,EAAK7G,OAAS,GAErC,EAAKS,MAAMwB,IAAI2F,EAAMnH,OAKjC,EAAK+C,cAAgB,IAAIqE,IAAY,EAAKjB,UAAW,EAAKA,UAAW,EAAKA,WAC1E,EAAKnD,cAAgB,IAAIqE,IAAkB,CACvC9G,MAAO,IAAIW,IAAM,WACjByC,KAAMG,MAEV,EAAK8C,WAAa,IAAIU,IAAc,EAAKvE,cAAe,EAAKC,cAAe,EAAKqD,QACjF,EAAKO,WAAWrF,YAAc,EAC9B,EAAKvB,MAAMwB,IAAI,EAAKoF,YAEpB,EAAKC,kBAAoB,IAAIO,IAAY,EAAKjB,UAAW,EAAKA,UAAW,EAAKA,WAC9E,EAAKW,kBAAoB,IAAIO,IAAkB,CAC3C9G,MAAO,IAAIW,IAAM,WACjByC,KAAMG,MAEV,EAAKiD,cAAgB,IAAIO,IAAc,EAAKT,kBAAmB,EAAKC,kBAAmB,EAAKT,QAC5F,EAAKU,cAAcxF,YAAc,EACjC,EAAKvB,MAAMwB,IAAI,EAAKuF,eAEpB,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAK1G,KAAM0G,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAK3G,KAAM2G,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAK5G,KAAM4G,IAAK,CAChC,IAAMxF,EAAKsF,EAAIC,EAAI,EAAK3G,KAAO4G,GAAK,EAAK5G,KAAO,EAAKA,MACrD,EAAKsG,WAAWW,YACZ7F,GACA,IAAI8F,KAAUC,kBACRT,EAAI,EAAKZ,QAAU,EAAK7G,OAAS,KACjC0H,EAAI,EAAKb,QAAU,EAAK7G,OAAS,KACjC2H,EAAI,EAAKd,QAAU,EAAK7G,OAAS,KAI3C,EAAKwH,cAAcQ,YACf7F,GACA,IAAI8F,KACCC,kBACKT,EAAI,EAAKZ,QAAU,EAAK7G,OAAS,GAAK,MACtC0H,EAAI,EAAKb,QAAU,EAAK7G,OAAS,GAAK,MACtC2H,EAAI,EAAKd,QAAU,EAAK7G,OAAS,GAAK,KAE3Ca,MACG,IAAIoD,IAAQ,KAAM,KAAM,QA7ElD,OAoFE,EAAK+C,WAAa,IAAImB,EAAW,EAAKnI,OAAQ,EAAK4G,UAAW,EAAKC,SApFrE,EAvBN,sDA+GcuB,GACNzH,KAAKsG,QAAQoB,KAAKD,GAClBzH,KAAKF,MAAMwB,IAAImG,EAAO3H,SAjH9B,6BAoHWkC,GACH,GAAIhC,KAAKyG,qBAAuBzG,KAAKwG,qBAAsB,CAQvD,IAPA,IAAM3F,EAAO6E,EAAKiC,OAAOrF,EAAU,EAAGoD,EAAKkC,UACrC9G,EAASwB,EAAU,EJ5IP,KI8IZgC,EAAQ,IAAIiC,MACZ5D,EAAQ,IAAIW,IAAQ,EAAG,EAAG,GAC1BuE,EAAO,IAAIvE,IAAQ,EAAG,EAAG,GAEtBlE,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,IAAIqF,EAAYG,EAAUC,GAC1B,OAAQvC,EAAU,EAAG,IACjB,KAAK,EACDmC,EAAYG,EAAUC,GACtB,MACJ,KAAK,EACDJ,EAAYG,EAAUE,KACtB,MACJ,KAAK,EACDL,EAAYG,EAAUG,KACtB,MACJ,KAAK,EACDN,EAAYG,EAAUI,MACtB,MACJ,KAAK,EACDP,EAAYG,EAAUK,QACtB,MACJ,KAAK,EACDR,EAAYG,EAAUM,KAI9B,IAAM4C,GAAI,IAAIxE,KAAU5B,KAAK+C,EAAUE,QAAQxD,eAAenB,KAAKkG,SAC7DlC,GAAO,IAAIV,KAAU5B,KAAKmG,GAAMvG,IAAIwG,GAEtC9D,EAAK8C,GAAK9G,KAAKX,OAAS,GAAK2E,EAAK8C,GAAK9G,KAAKX,OAAS,GACrD2E,EAAK+C,GAAK/G,KAAKX,OAAS,GAAK2E,EAAK+C,GAAK/G,KAAKX,OAAS,GACrD2E,EAAKgD,GAAKhH,KAAKX,OAAS,GAAK2E,EAAKgD,GAAKhH,KAAKX,OAAS,IAIzDiF,EAAMoD,KAAK,IAAIlD,EAASC,EAAWzE,KAAKkG,QAAS,OACjD2B,EAAKnG,KAAKsC,IAGd,IAAMyD,EAAS,IAAI/E,EACf7B,EACAC,EACA6B,EACA,IAAI0B,EAAKC,IAEbtE,KAAK+H,UAAUN,GAEfzH,KAAKwG,qBAAuC,GAAhB7E,KAAKc,SACjCzC,KAAKyG,mBAAqB,EAI9B,IADA,IAAMuB,EAAiC,GAC9B5I,EAAI,EAAGA,EAAIY,KAAKsG,QAAQjH,OAAQD,IAAK,CAC1C,IAAMqI,EAASzH,KAAKsG,QAAQlH,GAI5B,GAFAqI,EAAOQ,OAAOjG,GAEVyF,EAAOS,kBAAmB,CAC1B,IACMzG,EADQzB,KAAKmI,6BAA6BV,EAAOxH,UAChCmI,OAAOX,EAAO3G,OAAQ2G,EAAO5G,MACpD4G,EAAOW,OAAO3G,GAGdgG,EAAOY,SACPrI,KAAKF,MAAMwI,OAAOb,EAAO3H,OACzBkI,EAAgBN,KAAKtI,IAI7B,IAAK,IAAIA,EAAI4I,EAAgB3I,OAAS,EAAGD,GAAK,EAAGA,IAC7CY,KAAKsG,QAAQiC,OAAOP,EAAgB5I,GAAI,KAhMpD,sDAoM6D,IAA3B0H,EAA0B,EAA1BA,EAAGC,EAAuB,EAAvBA,EAAGC,EAAoB,EAApBA,EAChC,OAAOhH,KAAKwI,SAAS,CACjB1B,GAAIA,EAAI9G,KAAKX,OAAS,GAAKW,KAAKkG,QAChCa,GAAIA,EAAI/G,KAAKX,OAAS,GAAKW,KAAKkG,QAChCc,GAAIA,EAAIhH,KAAKX,OAAS,GAAKW,KAAKkG,YAxM5C,kCAkNuC,IAAzBY,EAAwB,EAAxBA,EAAGC,EAAqB,EAArBA,EAAGC,EAAkB,EAAlBA,EACZ,OAAOhH,KAAKoG,OAAOU,GAAGC,GAAGC,OAnNjC,GAA6BnH,GAuNhB2H,EAAb,kDAII,WAAYnI,EAAgB4G,EAAmBC,GAAkB,IAAD,uBAC5D,gBAJKuC,cAGuD,IAFvDC,cAEuD,EAG5D,EAAKD,SAAW,IAAIE,IAAkB,CAClCtI,MAAO,IAAIW,IAAM,aAMrB,IAHA,IAAM4H,EAAavJ,EAAS,EAEtBwJ,EAAS,IAAItC,MACVuC,GAAKF,EAAYE,GAAKF,EAAYE,GAAK5C,EAC5C,IAAK,IAAI6C,GAAKH,EAAYG,GAAKH,EAAYG,GAAK7C,EAC5C,IAAK,IAAI8C,GAAKJ,EAAYI,EAAIJ,EAAYI,GAAK9C,EAAS,CACpD,IAAM+C,EAAWD,EAAI/C,EAAY,EAC3BiD,EAASF,EAAI9C,EAAUD,EAAY,EAGnCkD,EAAkB,IADND,EAASD,GAG3BJ,EAAOnB,KAAK,IAAIpE,IACZwF,EACAC,EACAE,IAGJJ,EAAOnB,KAAK,IAAIpE,IACZwF,EACAC,EACAE,EAAWE,IAGfN,EAAOnB,KAAK,IAAIpE,IACZwF,EACAC,EACAG,EAASC,IAGbN,EAAOnB,KAAK,IAAIpE,IACZwF,EACAC,EACAG,IAIJL,EAAOnB,KAAK,IAAIpE,IACZwF,EACAG,EACAF,IAGJF,EAAOnB,KAAK,IAAIpE,IACZwF,EACAG,EAAWE,EACXJ,IAGJF,EAAOnB,KAAK,IAAIpE,IACZwF,EACAI,EAASC,EACTJ,IAGJF,EAAOnB,KAAK,IAAIpE,IACZwF,EACAI,EACAH,IAIJF,EAAOnB,KAAK,IAAIpE,IACZ2F,EACAH,EACAC,IAGJF,EAAOnB,KAAK,IAAIpE,IACZ2F,EAAWE,EACXL,EACAC,IAGJF,EAAOnB,KAAK,IAAIpE,IACZ4F,EAASC,EACTL,EACAC,IAGJF,EAAOnB,KAAK,IAAIpE,IACZ4F,EACAJ,EACAC,IA1F4C,OAgG5D,EAAKL,SAAW,IAAIU,KAAa,IAAIC,KAAiBC,cAAcT,GAAS,EAAKJ,UAClF,EAAKC,SAASa,uBACd,EAAKzJ,MAAMwB,IAAI,EAAKoH,UAlGwC,EAJpE,UAAgC7I,G,wBCtOX2J,E,WAUjB,WAAoBC,GAA4B,yBAA5BA,SAA2B,KATvCC,cASuC,OARvCC,aAQuC,OAPvCC,YAOuC,OANvCC,cAMuC,OALvCC,WAKuC,OAJvCC,aAIuC,OAHvCC,SAGuC,OAFvCC,aAEuC,EAC3CjK,KAAK0J,SAAW,IAAIQ,IAAc,CAC9BT,OAAQzJ,KAAKyJ,OACbU,WAAW,IAEfnK,KAAK0J,SAASU,QAAQX,EAAOY,YAAaZ,EAAOa,cAEjDtK,KAAK4J,OAAS,IAAIW,IAAkB,GAAId,EAAOY,YAAcZ,EAAOa,aAAc,EAAG,KACrFtK,KAAK6J,SAAW,IAAIW,IAAcxK,KAAK4J,OAAQ5J,KAAKyJ,QAEpDzJ,KAAK6J,SAASY,cAAgB9I,KAAK+I,GAAK,EAExC1K,KAAK6J,SAASc,cAAgB,KAC9B3K,KAAK6J,SAASe,eAAgB,EAE9B5K,KAAK4J,OAAO3J,SAASnB,IAAI,IAAK,IAAK,KACnCkB,KAAK6J,SAAS5B,SAEdjI,KAAK8J,MAAQ,IAAIe,IACjB7K,KAAK8J,MAAMgB,WAAa,IAAI9J,IAAM,WAElChB,KAAK+J,QAAU,IAAIgB,IAAa,UAAW,GAC3C/K,KAAK8J,MAAMxI,IAAItB,KAAK+J,SAEpB/J,KAAKgK,IAAM,IAAIgB,IAAW,UAAW,IACrChL,KAAKgK,IAAI/J,SAASnB,IAAI,IAAK,IAAK,KAChCkB,KAAK8J,MAAMxI,IAAItB,KAAKgK,KAEpBhK,KAAKiK,QAAU,IAAIjE,EAAQ,EAAG,GAAI,KAElChG,KAAK8J,MAAMxI,IAAItB,KAAKiK,QAAQnK,OAE5BE,KAAK2J,QAAU,IAAIsB,IAAejL,KAAK0J,UACvC1J,KAAK2J,QAAQuB,QAAQ,IAAIC,IAAWnL,KAAK8J,MAAO9J,KAAK4J,S,iDAGpD5H,GACDhC,KAAKiK,QAAQhC,OAAOjG,GAGpBhC,KAAK4J,OAAOwB,OAASpL,KAAKyJ,OAAOY,YAAcrK,KAAKyJ,OAAOa,aAC3DtK,KAAK4J,OAAOyB,yBAGZrL,KAAK0J,SAASU,QAAQpK,KAAKyJ,OAAOY,YAAarK,KAAKyJ,OAAOa,cAE3DtK,KAAK6J,SAAS5B,SACdjI,KAAK2J,QAAQ2B,a,KC3DAC,E,kDAIjB,WAAYC,GAAY,IAAD,8BACnB,cAAMA,IAJFC,IAAMC,IAAMC,YAGG,EAFfC,UAEe,I,gEAIF,IAAD,OACZ5L,KAAKyL,IAAII,UACT7L,KAAK4L,KAAO,IAAIpC,EAAKxJ,KAAKyL,IAAII,UAGlC,IAAIC,EAAeC,YAAYC,MAS/BC,uBARa,SAAPC,EAAQC,GACN,EAAKP,MACL,EAAKA,KAAKM,KAAKC,EAAcL,GAEjCA,EAAeK,EACfF,sBAAsBC,Q,+BAO1B,OACI,4BAAQE,UAAU,UAAUX,IAAKzL,KAAKyL,U,GA3BbC,IAAMW,WCQ5BC,MARf,WACE,OACE,yBAAKF,UAAU,OACb,kBAAC,EAAD,QCKcG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAAStB,OACP,kBAAC,IAAMuB,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.4e28da31.chunk.js","sourcesContent":["import {\n    BoxGeometry,\n    DataTexture,\n    EdgesGeometry,\n    Geometry,\n    LuminanceFormat,\n    NearestFilter,\n    SphereGeometry,\n    Texture\n} from \"three\";\n\nconst SPHERE_GEOMETRIES = new Map<number, Geometry>();\n\nexport const getCachedSphereGeometry = (radius: number): Geometry => {\n    if (SPHERE_GEOMETRIES.has(radius)) {\n        return SPHERE_GEOMETRIES.get(radius)!;\n    }\n\n    const geometry = new SphereGeometry(radius);\n    SPHERE_GEOMETRIES.set(radius, geometry);\n    return geometry;\n}\n\nconst BOX_GEOMETRIES = new Map<number, Geometry>();\n\nexport const getCachedBoxGeometry = (size: number): Geometry => {\n    if (BOX_GEOMETRIES.has(size)) {\n        return BOX_GEOMETRIES.get(size)!;\n    }\n\n    const geometry = new BoxGeometry(size, size, size);\n    BOX_GEOMETRIES.set(size, geometry);\n    return geometry;\n}\n\nconst EDGE_GEOMETRIES = new Map<number, EdgesGeometry>();\n\nexport const getCachedEdgesGeometry = (size: number): EdgesGeometry => {\n    if (EDGE_GEOMETRIES.has(size)) {\n        return EDGE_GEOMETRIES.get(size)!;\n    }\n\n    const geometry = new EdgesGeometry(getCachedBoxGeometry(size));\n    EDGE_GEOMETRIES.set(size, geometry);\n    return geometry;\n}\n\nconst GRADIENT_MAPS = new Map<number, Texture>();\n\nexport const getCachedGradientMap = (tones: number): Texture => {\n    if (GRADIENT_MAPS.has(tones)) {\n        return GRADIENT_MAPS.get(tones)!;\n    }\n\n    const texels = new Uint8Array( tones);\n    for (let i = 0; i <= texels.length; i ++ ) {\n        texels[i] = (i / texels.length) * 0x100;\n    }\n\n    const texture = new DataTexture(texels, texels.length, 1, LuminanceFormat);\n    texture.minFilter = NearestFilter;\n    texture.magFilter = NearestFilter;\n    texture.generateMipmaps = false;\n    GRADIENT_MAPS.set(tones, texture);\n\n    return texture;\n}\n\nexport const createGradientMap = (tones: number): Texture => {\n    const texels = new Uint8Array( tones);\n    for (let i = 0; i <= texels.length; i ++ ) {\n        texels[i] = (i / texels.length) * 0x100;\n    }\n\n    const texture = new DataTexture(texels, texels.length, 1, LuminanceFormat);\n    texture.minFilter = NearestFilter;\n    texture.magFilter = NearestFilter;\n    texture.generateMipmaps = false;\n    GRADIENT_MAPS.set(tones, texture);\n\n    return texture;\n}","import {Group, Vector3} from \"three\";\n\nexport default abstract class SceneNode {\n    readonly group: Group = new Group();\n\n    get position(): Vector3 {\n        return this.group.position;\n    }\n\n    get scale(): Vector3 {\n        return this.group.scale;\n    }\n}","import {\n    BackSide,\n    BoxGeometry,\n    Color, DataTexture,\n    EdgesGeometry, Geometry, Group,\n    LineBasicMaterial,\n    LineSegments,\n    LuminanceFormat, Material,\n    Mesh, MeshPhongMaterial,\n    MeshToonMaterial,\n    NearestFilter, OctahedronGeometry,\n    Texture\n} from 'three';\n\nimport {\n    getCachedSphereGeometry,\n    getCachedGradientMap,\n    getCachedBoxGeometry\n} from \"./geometry-cache\";\n\nimport SceneNode from \"./scene-node\";\nimport {Team} from \"./team\";\n\n/**\n * A voxel is a\n */\nexport class Voxel extends SceneNode {\n\n    readonly dotGeometry: Geometry;\n    readonly dotMaterial: MeshToonMaterial;\n    readonly dotMesh: Mesh;\n\n    team: Team | null = null;\n    health: number = 0;\n\n    constructor(\n        size: number,\n        color: Color,\n        gradientTones: number,\n        highlightColor: Color,\n        highlightScalar: number,\n        dotRadius: number,\n    ) {\n        super();\n\n        this.dotGeometry = getCachedSphereGeometry(dotRadius);\n        this.dotMaterial = new MeshToonMaterial({\n            color: new Color('#ff0000'),\n            gradientMap: getCachedGradientMap(gradientTones),\n        });\n        this.dotMesh = new Mesh(this.dotGeometry, this.dotMaterial);\n        this.dotMesh.scale.multiplyScalar(1.1);\n        this.dotMesh.visible = false;\n        this.dotMesh.renderOrder = 2;\n        this.group.add(this.dotMesh);\n    }\n\n    damage(amount: number, team: Team): number {\n        if (this.team !== null && this.team.id === team.id) {\n            return 0;\n        }\n\n        let overflow: number = 0;\n\n        if (this.health === 0) {\n            if (amount === 1) {\n                this.dotMaterial.color = new Color().copy(team.color);\n                this.dotMesh.visible = true;\n                this.health = 1;\n                overflow = 1;\n            } else {\n                this.dotMaterial.color = new Color().copy(team.color);\n                this.dotMesh.visible = true;\n                this.health = Math.floor(amount / 2);\n                overflow = amount - this.health;\n            }\n            this.team = team;\n        } else if (this.health - amount < 0) {\n            this.dotMaterial.color = new Color().copy(team.color);\n            this.dotMesh.visible = true;\n            this.health = Math.floor((amount - this.health) / 2);\n            overflow = amount - this.health;\n            this.team = null;\n        } else if(this.health - amount === 0) {\n            this.dotMaterial.color = new Color().copy(new Color('#111111'));\n            this.dotMesh.visible = false;\n            this.health = 0;\n            overflow = this.health;\n            this.team = null;\n        } else {\n            this.health -= amount;\n            overflow = amount;\n        }\n\n        const scale = Math.floor((this.health + 100) / 100) / 6;\n        this.dotMesh.scale.set(1, 1, 1).multiplyScalar(scale).multiplyScalar(1.1);\n\n        return overflow;\n    }\n}","export const MAXIMUM_HEALTH = 500;\n\nconst SCALAR_GRANULARITY = 5;\n\nexport const healthToScalar = (health: number): number => {\n    const k = MAXIMUM_HEALTH / SCALAR_GRANULARITY;\n    return Math.floor(((health + k) / k)) / (SCALAR_GRANULARITY + 1);\n}","import {Color} from \"three\";\n\nexport const darkenColor = (color: Color, delta: number): Color => {\n    let {h, s, l} = color.getHSL({h: 0, s: 0, l: 0});\n    l -= delta;\n    if (l < 0) {\n        l = 0;\n    }\n    return new Color().setHSL(h, s, l);\n}\n\nexport const randomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min)) + min;\n}","import {\n    BackSide,\n    Color, DataTexture, FrontSide, Geometry,\n    Group, LuminanceFormat, Material, MathUtils,\n    Mesh,\n    MeshBasicMaterial,\n    MeshPhongMaterial, MeshToonMaterial, NearestFilter, OctahedronGeometry,\n    PointLight,\n    SphereGeometry,\n    Vector3\n} from \"three\";\nimport {getCachedGradientMap, getCachedSphereGeometry} from \"./geometry-cache\";\nimport SceneNode from \"./scene-node\";\nimport {healthToScalar} from \"./health\";\nimport {Dir} from \"fs\";\nimport {Team} from \"./team\";\nimport {darkenColor} from \"./utils\";\n\nconst RADIUS: number = 6;\n\nexport default class Tracer extends SceneNode {\n\n    readonly shellGeometry: Geometry;\n    readonly shellMaterial: MeshToonMaterial;\n    readonly shellMesh: Mesh;\n\n    readonly outlineGeometry: Geometry;\n    readonly outlineMaterial: MeshPhongMaterial;\n    readonly outlineMesh: Mesh;\n\n    private alpha: number = 0;\n    private stepTime: number = 0;\n    private stepSource: Vector3 = new Vector3();\n    private easing: (t: number) => number = sigmoid(5.5);\n\n    /**\n     *\n     * @param team\n     * @param start\n     * @param path\n     * @param health\n     */\n    constructor(\n        readonly team: Team,\n        public health: number,\n        readonly start: Vector3,\n        readonly path: Path,\n    ) {\n        super();\n\n        this.shellGeometry = getCachedSphereGeometry(RADIUS);\n        this.shellMaterial = new MeshToonMaterial({\n            color: team.color,\n            gradientMap: getCachedGradientMap(10),\n            side: FrontSide\n        });\n        this.shellMesh = new Mesh(this.shellGeometry, this.shellMaterial);\n        this.shellMesh.renderOrder = 1;\n        this.group.add(this.shellMesh);\n\n        this.outlineGeometry = getCachedSphereGeometry(RADIUS);\n        this.outlineMaterial = new MeshPhongMaterial({\n            color: darkenColor(this.team.color, 0.2),\n            side: BackSide\n        });\n        this.outlineMesh = new Mesh(this.outlineGeometry, this.outlineMaterial);\n        this.outlineMesh.scale.multiplyScalar(1.05);\n        this.outlineMesh.renderOrder = 0;\n        this.group.add(this.outlineMesh);\n\n        this.position.copy(this.stepSource);\n        this.scale.multiplyScalar(healthToScalar(this.health));\n\n        this.stepSource.copy(this.start);\n    }\n\n    /**\n     * Damages the tracer, updating its scale as needed.\n     *\n     * @param amount the amount of damage to apply to the tracer.\n     */\n    damage(amount: number) {\n        this.health -= amount;\n        if (this.health < 0) {\n            this.health = 0;\n        }\n\n        if (this.health !== 0) {\n            this.group.scale.set(1, 1, 1).multiplyScalar(healthToScalar(this.health));\n        }\n    }\n\n    update(delta: number) {\n        if (this.path.complete()) {\n            return;\n        }\n\n        const step = this.path.peek();\n        const dest = new Vector3().addVectors(\n            this.stepSource,\n            step.delta(),\n        );\n\n        this.stepTime += delta;\n\n        this.alpha = this.easing(this.stepTime / step.time);\n        if (this.alpha > 1) {\n            this.alpha = 1;\n        }\n\n        this.position.copy(new Vector3().lerpVectors(this.stepSource, dest, this.alpha));\n\n        if (this.alpha === 1.0) {\n            this.path.poll();\n\n            this.stepSource = dest;\n            this.alpha = this.stepTime = 0;\n        }\n    }\n\n    hasReachedVoxel(): boolean {\n        return this.alpha === 0;\n    }\n\n    /**\n     * Gets if the tracer is dead either because it has zero health or it reached the end of its path.\n     */\n    dead() : boolean {\n        return this.health === 0 || this.path.complete();\n    }\n}\n\nexport class Path {\n    private index = 0;\n\n    constructor(readonly steps: PathStep[]) {}\n\n    peek(): PathStep {\n        return this.steps[this.index];\n    }\n\n    poll(): PathStep {\n        return this.steps[this.index++];\n    }\n\n    complete(): boolean {\n        return this.index === this.steps.length;\n    }\n}\n\nexport class PathStep {\n\n    /**\n     *\n     * @param direction\n     * @param distance\n     * @param time the time in milliseconds that the step should be taken.\n     */\n    constructor(readonly direction: Direction, readonly distance: number, readonly time: number) {\n    }\n\n    delta(): Vector3 {\n        return new Vector3().copy(this.direction.vector).multiplyScalar(this.distance);\n    }\n}\n\nexport class Direction {\n    public static UP = new Direction(new Vector3(0, 1, 0));\n    public static DOWN = new Direction(new Vector3(0, -1, 0));\n    public static LEFT = new Direction(new Vector3(1, 0, 0));\n    public static RIGHT = new Direction(new Vector3(-1, 0, 0));\n    public static FORWARD = new Direction(new Vector3(0, 0, 1));\n    public static BACK = new Direction(new Vector3(0, 0, -1));\n\n    private constructor(readonly vector: Vector3) {}\n}\n\n/**\n * Factory for sigmoid functions with a specific k value. For more information about sigmoid functions go here:\n * https://en.wikipedia.org/wiki/Sigmoid_function.\n *\n * @param k the sigmoid k value.\n */\nconst sigmoid = (k: number) => {\n    const base = (t: number) => {\n        return (1 / (1 + Math.exp(-k * t))) - 0.5;\n    }\n\n    const correction = 0.5 / base(1);\n\n    return (t: number): number => {\n        t = MathUtils.clamp(t, 0, 1);\n        return correction * base(2 * t - 1) + 0.5;\n    }\n}","import {Color} from \"three\";\n\nexport class Team {\n    private static ALL = new Map<number, Team>();\n\n    public static TEAM_A = new Team(0, new Color().setHSL(0.0, 0.5, 0.5));\n    public static TEAM_B = new Team(1, new Color().setHSL(0.4, 0.5, 0.5));\n    public static TEAM_C = new Team(2, new Color().setHSL(0.6, 0.5, 0.5));\n    public static TEAM_D = new Team(3, new Color().setHSL(0.8, 0.5, 0.5));\n\n    private constructor(readonly id: number, readonly color: Color) {\n        Team.ALL.set(id, this);\n    }\n\n    public static fromID(id: number): Team | undefined {\n        return Team.ALL.get(id);\n    }\n\n    public static count(): number {\n        return Team.ALL.size;\n    }\n}","import {Voxel} from './voxel';\nimport {\n    BackSide,\n    BoxGeometry,\n    BufferGeometry,\n    Color, Geometry,\n    InstancedBufferGeometry, InstancedMesh,\n    LineBasicMaterial,\n    LineDashedMaterial,\n    LineSegments,\n    Material, Matrix4, MeshBasicMaterial, MeshToonMaterial,\n    Vector3\n} from \"three\";\nimport {Point} from \"./point\";\nimport Tracer, {Direction, Path, PathStep} from \"./tracer\";\nimport SceneNode from \"./scene-node\";\nimport {MAXIMUM_HEALTH} from \"./health\";\nimport {randomInt} from \"./utils\";\nimport {Team} from \"./team\";\nimport {createGradientMap, getCachedBoxGeometry, getCachedGradientMap} from \"./geometry-cache\";\n\nexport class Lattice extends SceneNode {\n    readonly volume: number;\n    readonly length: number;\n    readonly voxels: Voxel[][][];\n    readonly guidelines: Guidelines;\n    readonly tracers: Tracer[] = new Array<Tracer>();\n\n    // TODO: Remove.\n    private tracerSpawnThreshold: number = 300;\n    private tracerSpawnCounter: number = 0;\n\n    private shellGeometry: BoxGeometry;\n    private shellMaterial: MeshBasicMaterial;\n    private shellsMesh: InstancedMesh;\n\n    private highlightGeometry: BoxGeometry;\n    private highlightMaterial: MeshBasicMaterial;\n    private highlightMesh: InstancedMesh;\n\n    constructor(\n        readonly size: number,\n        readonly voxelSize: number,\n        readonly spacing: number\n    ) {\n        super();\n\n        this.volume = this.size * this.size * this.size;\n\n        this.length = (this.size - 1) * this.spacing;\n\n        this.voxels = new Array<Array<Array<Voxel>>>(this.size);\n        for (let x = 0; x < this.size; x++) {\n            this.voxels[x] = new Array<Array<Voxel>>(this.size);\n            for (let y = 0; y < this.size; y++) {\n                this.voxels[x][y] = new Array<Voxel>(this.size);\n            }\n        }\n\n        for (let x = 0; x < this.size; x++) {\n            for (let y = 0; y < this.size; y++) {\n                for (let z = 0; z < this.size; z++) {\n                    const voxel = this.voxels[x][y][z] = new Voxel(\n                        voxelSize,\n                        new Color('#111111'),\n                        5,\n                        new Color('#ffffff'),\n                        1.05,\n                        6\n                    );\n\n                    voxel.group.position.set(\n                        x * this.spacing - this.length / 2,\n                        y * this.spacing - this.length / 2,\n                        z * this.spacing - this.length / 2\n                    );\n                    this.group.add(voxel.group);\n                }\n            }\n        }\n\n        this.shellGeometry = new BoxGeometry(this.voxelSize, this.voxelSize, this.voxelSize);\n        this.shellMaterial = new MeshBasicMaterial({\n            color: new Color('#111111'),\n            side: BackSide\n        })\n        this.shellsMesh = new InstancedMesh(this.shellGeometry, this.shellMaterial, this.volume);\n        this.shellsMesh.renderOrder = 0;\n        this.group.add(this.shellsMesh);\n\n        this.highlightGeometry = new BoxGeometry(this.voxelSize, this.voxelSize, this.voxelSize);\n        this.highlightMaterial = new MeshBasicMaterial({\n            color: new Color('#ffffff'),\n            side: BackSide\n        })\n        this.highlightMesh = new InstancedMesh(this.highlightGeometry, this.highlightMaterial, this.volume);\n        this.highlightMesh.renderOrder = 1;\n        this.group.add(this.highlightMesh);\n\n        for (let x = 0; x < this.size; x++) {\n            for (let y = 0; y < this.size; y++) {\n                for (let z = 0; z < this.size; z++) {\n                    const id = x + y * this.size + z * (this.size * this.size);\n                    this.shellsMesh.setMatrixAt(\n                        id,\n                        new Matrix4().makeTranslation(\n                            -(x * this.spacing - this.length / 2),\n                            -(y * this.spacing - this.length / 2),\n                            -(z * this.spacing - this.length / 2)\n                        ),\n                    );\n\n                    this.highlightMesh.setMatrixAt(\n                        id,\n                        new Matrix4()\n                            .makeTranslation(\n                                -(x * this.spacing - this.length / 2) - 0.01,\n                                -(y * this.spacing - this.length / 2) - 0.01,\n                                -(z * this.spacing - this.length / 2) - 0.01\n                            )\n                            .scale(\n                                new Vector3(1.05, 1.05, 1.05)\n                            ),\n                    );\n                }\n            }\n        }\n\n        this.guidelines = new Guidelines(this.length, this.voxelSize, this.spacing);\n        //this.group.add(this.guidelines.segments);\n    }\n\n    addTracer(tracer: Tracer) {\n        this.tracers.push(tracer);\n        this.group.add(tracer.group);\n    }\n\n    update(delta: number) {\n        if (this.tracerSpawnCounter++ > this.tracerSpawnThreshold) {\n            const team = Team.fromID(randomInt(0, Team.count()))!;\n            const health = randomInt(1, MAXIMUM_HEALTH);\n\n            const steps = new Array<PathStep>();\n            const start = new Vector3(0, 0, 0);\n            const curr = new Vector3(0, 0, 0);\n\n            for (let i = 0; i < 32; i++) {\n                let direction = Direction.UP;\n                switch (randomInt(0, 6)) {\n                    case 0:\n                        direction = Direction.UP;\n                        break;\n                    case 1:\n                        direction = Direction.DOWN;\n                        break;\n                    case 2:\n                        direction = Direction.LEFT;\n                        break;\n                    case 3:\n                        direction = Direction.RIGHT;\n                        break;\n                    case 4:\n                        direction = Direction.FORWARD;\n                        break;\n                    case 5:\n                        direction = Direction.BACK;\n                        break;\n                }\n\n                const v = new Vector3().copy(direction.vector).multiplyScalar(this.spacing);\n                const dest = new Vector3().copy(curr).add(v)\n\n                if (dest.x < -this.length / 2 || dest.x > +this.length / 2 ||\n                    dest.y < -this.length / 2 || dest.y > +this.length / 2 ||\n                    dest.z < -this.length / 2 || dest.z > +this.length / 2) {\n                    continue;\n                }\n\n                steps.push(new PathStep(direction, this.spacing, 1500));\n                curr.copy(dest);\n            }\n\n            const tracer = new Tracer(\n                team,\n                health,\n                start,\n                new Path(steps),\n            );\n            this.addTracer(tracer);\n\n            this.tracerSpawnThreshold = Math.random() * 64;\n            this.tracerSpawnCounter = 0;\n        }\n\n        const completeTracers: Array<number> = [];\n        for (let i = 0; i < this.tracers.length; i++) {\n            const tracer = this.tracers[i];\n\n            tracer.update(delta);\n\n            if (tracer.hasReachedVoxel()) {\n                const voxel = this.getVoxelFromWorldCoordinates(tracer.position);\n                const overflow = voxel.damage(tracer.health, tracer.team);\n                tracer.damage(overflow);\n            }\n\n            if (tracer.dead()) {\n                this.group.remove(tracer.group);\n                completeTracers.push(i);\n            }\n        }\n\n        for (let i = completeTracers.length - 1; i >= 0; i--) {\n            this.tracers.splice(completeTracers[i], 1);\n        }\n    }\n\n    getVoxelFromWorldCoordinates({x, y, z}: Vector3): Voxel {\n        return this.getVoxel({\n            x: (x + this.length / 2) / this.spacing,\n            y: (y + this.length / 2) / this.spacing,\n            z: (z + this.length / 2) / this.spacing\n        });\n    }\n\n    /**\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    getVoxel({x, y, z}: Point): Voxel {\n        return this.voxels[x][y][z];\n    }\n}\n\nexport class Guidelines extends SceneNode {\n    readonly material: Material;\n    readonly segments: LineSegments;\n\n    constructor(length: number, voxelSize: number, spacing: number) {\n        super();\n\n        this.material = new LineBasicMaterial({\n            color: new Color('#ffffff'),\n        });\n\n        const halfLength = length / 2;\n\n        const points = new Array<Vector3>();\n        for (let a = -halfLength; a <= halfLength; a += spacing) {\n            for (let b = -halfLength; b <= halfLength; b += spacing) {\n                for (let c = -halfLength; c < halfLength; c += spacing) {\n                    const gapStart = c + voxelSize / 2;\n                    const gapEnd = c + spacing - voxelSize / 2;\n\n                    const gapLength = gapEnd - gapStart;\n                    const len = gapLength * 0.10;\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapStart,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapStart + len,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapEnd - len,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        b,\n                        gapEnd,\n                    ));\n\n\n                    points.push(new Vector3(\n                        a,\n                        gapStart,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        gapStart + len,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        gapEnd - len,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        a,\n                        gapEnd,\n                        b,\n                    ));\n\n\n                    points.push(new Vector3(\n                        gapStart,\n                        a,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        gapStart + len,\n                        a,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        gapEnd - len,\n                        a,\n                        b,\n                    ));\n\n                    points.push(new Vector3(\n                        gapEnd,\n                        a,\n                        b,\n                    ));\n                }\n            }\n        }\n\n        this.segments = new LineSegments(new BufferGeometry().setFromPoints(points), this.material);\n        this.segments.computeLineDistances();\n        this.group.add(this.segments);\n    }\n}","import {AmbientLight, Color, PerspectiveCamera, PointLight, Scene, WebGLRenderer} from \"three\";\nimport {Lattice} from \"./lattice\";\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\nimport {EffectComposer} from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport {RenderPass} from \"three/examples/jsm/postprocessing/RenderPass\";\n\nexport default class Game {\n    private renderer: WebGLRenderer;\n    private effects: EffectComposer;\n    private camera: PerspectiveCamera;\n    private controls: OrbitControls;\n    private scene: Scene;\n    private ambient: AmbientLight;\n    private sun: PointLight;\n    private lattice: Lattice;\n\n    constructor(private canvas: HTMLCanvasElement) {\n        this.renderer = new WebGLRenderer({\n            canvas: this.canvas,\n            antialias: true,\n        });\n        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);\n\n        this.camera = new PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 1, 2000);\n        this.controls = new OrbitControls(this.camera, this.canvas);\n\n        this.controls.maxPolarAngle = Math.PI / 2;\n\n        this.controls.dampingFactor = 0.025;\n        this.controls.enableDamping = true;\n\n        this.camera.position.set(400, 400, 400);\n        this.controls.update();\n\n        this.scene = new Scene();\n        this.scene.background = new Color('#000000');\n\n        this.ambient = new AmbientLight('#ffffff', 1.0);\n        this.scene.add(this.ambient);\n\n        this.sun = new PointLight('#ffffff', 0.5);\n        this.sun.position.set(800, 800, 800);\n        this.scene.add(this.sun);\n\n        this.lattice = new Lattice(9, 16, 100);\n\n        this.scene.add(this.lattice.group);\n\n        this.effects = new EffectComposer(this.renderer);\n        this.effects.addPass(new RenderPass(this.scene, this.camera));\n    }\n\n    draw(delta: number) {\n        this.lattice.update(delta);\n\n        // TODO(271): Only call this when the element has been resized.\n        this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n        this.camera.updateProjectionMatrix();\n\n        // TODO(271): Only call this when the element has been resized.\n        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\n\n        this.controls.update();\n        this.effects.render();\n    }\n}","import React from 'react';\nimport './Display.css';\nimport Game from \"./game/game\";\n\nexport default class Display extends React.Component<{}, {}>{\n    private ref = React.createRef<HTMLCanvasElement>();\n    private game?: Game;\n\n    constructor(props: {}) {\n        super(props);\n    }\n\n    componentDidMount() {\n        if (this.ref.current) {\n            this.game = new Game(this.ref.current);\n        }\n\n        let previousTime = performance.now();\n        const draw = (currentTime: number) => {\n            if (this.game) {\n                this.game.draw(currentTime - previousTime);\n            }\n            previousTime = currentTime;\n            requestAnimationFrame(draw);\n        };\n\n        requestAnimationFrame(draw);\n    }\n\n    render() {\n        return (\n            <canvas className=\"stretch\" ref={this.ref}>\n\n            </canvas>\n        );\n    }\n}","import React from 'react';\nimport './App.css';\nimport Display from \"./Display\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Display/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}